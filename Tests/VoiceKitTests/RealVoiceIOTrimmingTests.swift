//
//  RealVoiceIOTrimmingTests.swift
//  VoiceKit
//
//  Generated by GPT-5 (OpenAI) — collaborator: rdoggett
//  date: 09-17-2025
//

import XCTest
@testable import VoiceKit
@preconcurrency import AVFoundation

@MainActor
internal final class RealVoiceIOTrimmingTests: XCTestCase {

    // Create a tiny mono PCM buffer and write to file
    private func makeTempAudio(duration: Double = 0.25,
                               sampleRate: Double = 44100,
                               toneHz: Double = 440.0,
                               silenceHead: Double = 0.03,
                               silenceTail: Double = 0.04) throws -> URL {
        let total = Int(duration * sampleRate)
        let format = AVAudioFormat(standardFormatWithSampleRate: sampleRate, channels: 1)!
        guard let buffer = AVAudioPCMBuffer(pcmFormat: format, frameCapacity: AVAudioFrameCount(total)) else {
            throw NSError(domain: "test", code: -1)
        }
        buffer.frameLength = AVAudioFrameCount(total)

        // Fill with head silence, tone, tail silence
        let ch = buffer.floatChannelData!.pointee
        let head = Int(silenceHead * sampleRate)
        let tail = Int(silenceTail * sampleRate)
        let body = max(0, total - head - tail)
        for i in 0..<total {
            if i < head || i >= head + body {
                ch[i] = 0
            } else {
                let time = Float(i - head) / Float(sampleRate)
                ch[i] = sin(2 * .pi * Float(toneHz) * time) * 0.2
            }
        }

        let url = FileManager.default.temporaryDirectory.appendingPathComponent("trim-\(UUID().uuidString).caf")
        let file = try AVAudioFile(forWriting: url, settings: format.settings)
        try file.write(from: buffer)
        return url
    }

    func testTrimAudioSmartWithFallbackEnergy() throws {
        let io = RealVoiceIO()
        let url = try makeTempAudio()
        // Force fallback path by passing nil STT timestamps
        let out = io.trimAudioSmart(inputURL: url, sttStart: nil, sttEnd: nil, prePad: 0.0, postPad: 0.0)
        XCTAssertNotNil(out)
        // When trimming works, output URL should differ (added .trim.caf)
        XCTAssertEqual(out?.path.hasSuffix(".trim.caf"), true)
    }

    func testTrimAudioRespectsPadsAndBounds() throws {
        let io = RealVoiceIO()
        let url = try makeTempAudio(duration: 0.3)
        // Provide fake STT timestamps that bracket the tone
        if let trimmed = io.trimAudioSmart(inputURL: url, sttStart: 0.05, sttEnd: 0.22, prePad: 0.02, postPad: 0.02) {
            // Verify output is readable
            let file = try AVAudioFile(forReading: trimmed)
            XCTAssertGreaterThan(file.length, 0)
        } else {
            XCTFail("trimmed audio URL is nil")
        }
    }

    func testTrimAudioPrefersEnergyWhenSttWindowIsTiny() throws {
        let io = RealVoiceIO()

        // Create a slightly longer clip so “tiny” STT window is meaningful.
        let url = try makeTempAudio(duration: 0.6, silenceHead: 0.05, silenceTail: 0.05)

        // Provide STT timestamps that represent a very short span in the middle.
        // Heuristic in trimAudioSmart should consider this “tiny” relative to
        // the total duration and fall back to energy-based bounds.
        let sttStart: Double = 0.28
        let sttEnd: Double = 0.30 // 0.02 s

        guard let trimmed = io.trimAudioSmart(
            inputURL: url,
            sttStart: sttStart,
            sttEnd: sttEnd,
            prePad: 0.02,
            postPad: 0.02
        ) else {
            return XCTFail("Expected non-nil trimmed URL")
        }

        let file = try AVAudioFile(forReading: trimmed)
        let duration = Double(file.length) / file.fileFormat.sampleRate
        XCTAssertGreaterThan(duration, 0.05, "Trimmed file should not be effectively empty")
        XCTAssertLessThan(duration, 0.6, "Trimmed file should be shorter than the original")
    }
}
