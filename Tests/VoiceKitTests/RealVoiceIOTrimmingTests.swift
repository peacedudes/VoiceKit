//
//  RealVoiceIOTrimmingTests.swift
//  VoiceKit
//
//  Generated by GPT-5 (OpenAI) â€” collaborator: rdoggett
//  date: 09-17-2025
//

import XCTest
@testable import VoiceKit
@preconcurrency import AVFoundation

@MainActor
final class RealVoiceIOTrimmingTests: XCTestCase {

    // Create a tiny mono PCM buffer and write to file
    private func makeTempAudio(duration: Double = 0.25,
                               sampleRate: Double = 44100,
                               toneHz: Double = 440.0,
                               silenceHead: Double = 0.03,
                               silenceTail: Double = 0.04) throws -> URL {
        let total = Int(duration * sampleRate)
        let format = AVAudioFormat(standardFormatWithSampleRate: sampleRate, channels: 1)!
        guard let buffer = AVAudioPCMBuffer(pcmFormat: format, frameCapacity: AVAudioFrameCount(total)) else {
            throw NSError(domain: "test", code: -1)
        }
        buffer.frameLength = AVAudioFrameCount(total)

        // Fill with head silence, tone, tail silence
        let ch = buffer.floatChannelData!.pointee
        let head = Int(silenceHead * sampleRate)
        let tail = Int(silenceTail * sampleRate)
        let body = max(0, total - head - tail)
        for i in 0..<total {
            if i < head || i >= head + body {
                ch[i] = 0
            } else {
                let t = Float(i - head) / Float(sampleRate)
                ch[i] = sin(2 * .pi * Float(toneHz) * t) * 0.2
            }
        }

        let url = FileManager.default.temporaryDirectory.appendingPathComponent("trim-\(UUID().uuidString).caf")
        let file = try AVAudioFile(forWriting: url, settings: format.settings)
        try file.write(from: buffer)
        return url
    }

    func testTrimAudioSmartWithFallbackEnergy() throws {
        let io = RealVoiceIO()
        let url = try makeTempAudio()
        // Force fallback path by passing nil STT timestamps
        let out = io.trimAudioSmart(inputURL: url, sttStart: nil, sttEnd: nil, prePad: 0.0, postPad: 0.0)
        XCTAssertNotNil(out)
        // When trimming works, output URL should differ (added .trim.caf)
        XCTAssertEqual(out?.path.hasSuffix(".trim.caf"), true)
    }

    func testTrimAudioRespectsPadsAndBounds() throws {
        let io = RealVoiceIO()
        let url = try makeTempAudio(duration: 0.3)
        // Provide fake STT timestamps that bracket the tone
        let trimmed = io.trimAudioSmart(inputURL: url, sttStart: 0.05, sttEnd: 0.22, prePad: 0.02, postPad: 0.02)
        XCTAssertNotNil(trimmed)

        // Verify output is readable
        if let t = trimmed {
            let f = try AVAudioFile(forReading: t)
            XCTAssertGreaterThan(f.length, 0)
        }
    }
}
