//
//  ScriptedVoiceIOBehaviorTests.swift
//  VoiceKit
//
//  Generated by GPT-5 (OpenAI) â€” collaborator: rdoggett
//  date: 09-13-2025
//

import XCTest
import VoiceKitCore

@MainActor
final class ScriptedVoiceIOBehaviorTests: XCTestCase {

    private func b64(_ array: [String]) -> String {
        let data = try! JSONSerialization.data(withJSONObject: array, options: [])
        return data.base64EncodedString()
    }

    func testSpeakEmitsPulseAndTogglesSpeaking() async throws {
        guard let io = ScriptedVoiceIO(fromBase64: b64([])) else { return XCTFail("init failed") }

        let started = expectation(description: "speaking started")
        let ended = expectation(description: "speaking ended")
        var sawPulse = false

        io.onTTSSpeakingChanged = { isSpeaking in
            if isSpeaking { started.fulfill() } else { ended.fulfill() }
        }
        io.onTTSPulse = { level in
            if level > 0 { sawPulse = true }
        }

        await io.speak("hello")
        await fulfillment(of: [started, ended], timeout: 1.0)
        XCTAssertTrue(sawPulse, "Expected at least one non-zero pulse")
    }

    func testListenDequeuesAndFiresCallbacks() async throws {
        guard let io = ScriptedVoiceIO(fromBase64: b64(["first"])) else { return XCTFail("init failed") }

        let began = expectation(description: "listening began")
        let updated = expectation(description: "transcript updated")

        io.onListeningChanged = { if $0 { began.fulfill() } }
        io.onTranscriptChanged = { if $0 == "first" { updated.fulfill() } }

        let res = try await io.listen(timeout: 1, inactivity: 0.3, record: false)
        XCTAssertEqual(res.transcript, "first")
        await fulfillment(of: [began, updated], timeout: 1.0)
    }

    func testStopAllCancelsInFlightListenEpoch() async throws {
        guard let io = ScriptedVoiceIO(fromBase64: b64(["will-cancel"])) else { return XCTFail("init failed") }

        let begin = expectation(description: "listening began")
        io.onListeningChanged = { if $0 { begin.fulfill() } }

        // Run the listen task on the main actor to keep isolation simple.
        let task = Task { @MainActor in
            try? await io.listen(timeout: 2, inactivity: 1, record: false)
        }

        await fulfillment(of: [begin], timeout: 0.5)
        // Cancel the in-flight listen quickly to flip epoch
        io.stopAll()

        _ = await task.value
        // If we reached here without crash, epoch-based cancel worked.
        XCTAssertTrue(true)
    }
}
