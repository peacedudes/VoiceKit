//
//  ListenFlowSeamTests.swift
//  VoiceKitCoreTests
//
//  Generated by GPT-5 (OpenAI) — collaborator: rdoggett
//  date: 09-17-2025
//

import XCTest
@testable import VoiceKitCore
@preconcurrency import AVFoundation
@preconcurrency import Speech

// Fake seams for deterministic listen tests.

struct FakeSpeechTaskDriver: SpeechTaskDriver {
    let scripted: [SpeechEvent]

    func startTask(recognizer: SFSpeechRecognizer,
                   request: SFSpeechAudioBufferRecognitionRequest,
                   handler: @escaping @Sendable Handler) -> SFSpeechRecognitionTask {
        final class DummyTask: SFSpeechRecognitionTask {}
        let task = DummyTask()

        // Build an async sequence of events without spawning a detached Task.
        struct ScriptedEvents: AsyncSequence {
            typealias Element = SpeechEvent
            let events: [SpeechEvent]
            struct Iterator: AsyncIteratorProtocol {
                var index = 0
                let events: [SpeechEvent]
                mutating func next() async -> SpeechEvent? {
                    guard index < events.count else { return nil }
                    let event = events[index]
                    index += 1
                    // tiny delay to mimic streaming
                    try? await Task.sleep(nanoseconds: 10_000_00)
                    return event
                }
            }
            func makeAsyncIterator() -> Iterator { Iterator(index: 0, events: events) }
        }

        // Consume on MainActor and invoke the handler there.
        Task { @MainActor in
            for await event in ScriptedEvents(events: scripted) {
                handler(event) // executed on MainActor; not “sent” to a concurrent executor
            }
        }

        return task
    }

    static func live() -> SpeechTaskDriver { self.init(scripted: []) }
}

final class FakeTapSource: RecognitionTapSource {
    private var isInstalled = false

    // Main-actor box to hold the callback.
    @MainActor
    final class BufferCallbackBox {
        private let callback: @Sendable (AVAudioPCMBuffer) -> Void
        init(callback: @escaping @Sendable (AVAudioPCMBuffer) -> Void) { self.callback = callback }
        func call(with buffer: AVAudioPCMBuffer) { callback(buffer) }
    }

    func installTap(engine: AVAudioEngine,
                    format: AVAudioFormat,
                    bufferSize: AVAudioFrameCount,
                    onBuffer: @escaping @Sendable (AVAudioPCMBuffer) -> Void) throws {
        // Mark installed, but do not read self later from async code.
        isInstalled = true

        // Capture everything we need into locals so the Task does not capture self.
        let installedAtStart = true // we will run a fixed small script; no mid-run checks
        let localFormat = format
        let localBufferSize = bufferSize

        // Create the boxed callback on MainActor.
        let box: BufferCallbackBox = MainActor.assumeIsolated { BufferCallbackBox(callback: onBuffer) }

        // Drive three buffers on MainActor without touching self.
        Task { @MainActor in
            guard installedAtStart else { return }
            for _ in 0..<3 {
                guard let buffer = AVAudioPCMBuffer(pcmFormat: localFormat, frameCapacity: localBufferSize) else { break }
                buffer.frameLength = localBufferSize
                if let channel = buffer.floatChannelData?.pointee {
                    for i in 0..<Int(localBufferSize) {
                        channel[i] = (i % 16 == 0) ? 0.12 : 0.0
                    }
                }
                box.call(with: buffer)
                try? await Task.sleep(nanoseconds: 10_000_00)
            }
        }
    }

    func removeTap(engine: AVAudioEngine) {
        // We don’t cancel the already-scheduled short MainActor task; just mark flag for symmetry.
        isInstalled = false
    }

    static func live() -> RecognitionTapSource { FakeTapSource() }
}

final class FakeBoostedProvider: BoostedNodesProvider {
    var engine: AVAudioEngine?
    var player: AVAudioPlayerNode?
    var eq: AVAudioUnitEQ?
    func ensure(format: AVAudioFormat) throws {}
    func reset() {}
    static func live() -> BoostedNodesProvider { FakeBoostedProvider() }
}

@MainActor
final class ListenFlowSeamTests: XCTestCase {

    func testListenEmitsTranscriptAndFinishesOnFinal() async throws {
        let scriptedEvents = [
            SpeechEvent(text: "one two", isFinal: false, segments: [(0.1, 0.2)]),
            SpeechEvent(text: "42", isFinal: true, segments: [(0.5, 0.2)])
        ]
        let io = RealVoiceIO(
            config: .init(),
            speechDriver: FakeSpeechTaskDriver(scripted: scriptedEvents),
            tapSource: FakeTapSource(),
            boostedProvider: FakeBoostedProvider()
        )
        io.setRecognitionContext(.init(expectation: .number))

        var observedTranscripts: [String] = []
        io.onTranscriptChanged = { observedTranscripts.append($0) }

        let result = try await io.listen(timeout: 1.0, inactivity: 0.4, record: false)
        XCTAssertEqual(result.transcript, "42")
        XCTAssertTrue(observedTranscripts.contains("42"))
    }

    func testListenInactivityTimerFinishes() async throws {
        let scriptedEvents = [
            SpeechEvent(text: "hello", isFinal: false, segments: [(0.1, 0.2)])
        ]
        let io = RealVoiceIO(
            config: .init(),
            speechDriver: FakeSpeechTaskDriver(scripted: scriptedEvents),
            tapSource: FakeTapSource(),
            boostedProvider: FakeBoostedProvider()
        )
        let result = try await io.listen(timeout: 2.0, inactivity: 0.2, record: false)
        XCTAssertNotNil(Optional(result.transcript))
    }
}
