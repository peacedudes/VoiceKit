//
//  ScriptedVoiceIOEdgeTests.swift
//  VoiceKit
//
//  Generated by GPT-5 (OpenAI) â€” collaborator: rdoggett
//  date: 09-14-2025
//

import XCTest
import VoiceKitCore

@MainActor
final class ScriptedVoiceIOEdgeTests: XCTestCase {

    private func base64(of strings: [String]) -> String {
        let data = try! JSONSerialization.data(withJSONObject: strings, options: [])
        return data.base64EncodedString()
    }

    func testListenReturnsEmptyWhenQueueEmpty() async throws {
        guard let voice = ScriptedVoiceIO(fromBase64: base64(of: [])) else {
            return XCTFail("Failed to build ScriptedVoiceIO")
        }

        let began = expectation(description: "listening began")
        let ended = expectation(description: "listening ended")
        voice.onListeningChanged = { isOn in
            if isOn { began.fulfill() } else { ended.fulfill() }
        }

        let result = try await voice.listen(timeout: 0.8, inactivity: 0.2, record: false)
        XCTAssertEqual(result.transcript, "")
        await fulfillment(of: [began, ended], timeout: 1.0)
    }

    func testTwoSpeaksToggleSpeakingAndEmitPulse() async throws {
        guard let voice = ScriptedVoiceIO(fromBase64: base64(of: [])) else {
            return XCTFail("Failed to build ScriptedVoiceIO")
        }

        let startedFirst = expectation(description: "speak 1 started")
        let endedFirst = expectation(description: "speak 1 ended")
        let startedSecond = expectation(description: "speak 2 started")
        let endedSecond = expectation(description: "speak 2 ended")

        var startCount = 0
        var endCount = 0
        var sawAnyPulse = false

        voice.onTTSSpeakingChanged = { speaking in
            if speaking {
                if startCount == 0 { startedFirst.fulfill() }
                else if startCount == 1 { startedSecond.fulfill() }
                startCount += 1
            } else {
                if endCount == 0 { endedFirst.fulfill() }
                else if endCount == 1 { endedSecond.fulfill() }
                endCount += 1
            }
        }
        voice.onTTSPulse = { level in if level > 0 { sawAnyPulse = true } }

        await voice.speak("first")
        await voice.speak("second")

        await fulfillment(of: [startedFirst, endedFirst, startedSecond, endedSecond], timeout: 2.0)
        XCTAssertTrue(sawAnyPulse, "Expected at least one non-zero pulse across speaks")
    }
}
