//
//  ChorusLabSelectedVoicesSection.swift
//  VoiceKitUI
//
//  Extracted scaffold for the “Selected voices” list section.
//  Next step: move the ForEach row UI and swipe actions here and wire callbacks.
//
//  Generated by GPT-5 (OpenAI) — collaborator: rdoggett
//  date: 10-31-2025
import SwiftUI
import VoiceKit

@MainActor
public struct ChorusLabSelectedVoicesSection: View {
    // Data
    @Binding var profiles: [TTSVoiceProfile]
    @Binding var lastDurationByID: [String: TimeInterval]

    // State
    var isCalibrating: Bool
    var calibratingVoiceID: String?
    var isPlaying: Bool

    // Display helpers
    var resolveName: (_ voiceID: String) -> String
    var timingCellWidth: CGFloat

    // Callbacks
    var onEdit: (_ index: Int) -> Void
    var onSync: (_ voiceID: String) -> Void
    var onDelete: (_ voiceID: String) -> Void

    public init(
        profiles: Binding<[TTSVoiceProfile]>,
        lastDurationByID: Binding<[String: TimeInterval]>,
        isCalibrating: Bool,
        calibratingVoiceID: String?,
        isPlaying: Bool,
        resolveName: @escaping (_ voiceID: String) -> String,
        timingCellWidth: CGFloat,
        onEdit: @escaping (_ index: Int) -> Void,
        onSync: @escaping (_ voiceID: String) -> Void,
        onDelete: @escaping (_ voiceID: String) -> Void
    ) {
        self._profiles = profiles
        self._lastDurationByID = lastDurationByID
        self.isCalibrating = isCalibrating
        self.calibratingVoiceID = calibratingVoiceID
        self.isPlaying = isPlaying
        self.resolveName = resolveName
        self.timingCellWidth = timingCellWidth
        self.onEdit = onEdit
        self.onSync = onSync
        self.onDelete = onDelete
    }

    public var body: some View {
        ForEach($profiles, id: \.id) { profile in
            // Unwrap binding element for read-only UI usage in this row
            let profileValue = profile.wrappedValue
            ChorusLabSelectedVoiceRow(
                name: resolveName(profileValue.id),
                rate: profileValue.rate,
                pitch: profileValue.pitch,
                volume: profileValue.volume,
                duration: lastDurationByID[profileValue.id],
                isCalibrating: calibratingVoiceID == profileValue.id,
                timingCellWidth: timingCellWidth
            )
            .contentShape(Rectangle())
            .onTapGesture {
                if let idx = profiles.firstIndex(where: { $0.id == profileValue.id }) {
                    onEdit(idx)
                }
            }
            .swipeActions(edge: .trailing, allowsFullSwipe: true) {
                // Put Sync first so full-swipe defaults to Sync (safer than Delete).
                Button {
                    onSync(profileValue.id)
                } label: {
                    Label("Sync", systemImage: "arrow.clockwise")
                }
                .disabled(isCalibrating || isPlaying)
                .tint(.blue)
                .accessibilityLabel("Synchronize this voice")
                .accessibilityHint("Calibrate this voice to the target time")

                Button(role: .destructive) {
                    onDelete(profileValue.id)
                } label: {
                    Label("Delete", systemImage: "trash")
                }
                .disabled(isCalibrating || isPlaying)
                .accessibilityLabel("Delete voice")
            }
        }
    }
}
