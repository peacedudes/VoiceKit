//
//  RealVoiceIO+Boosted.swift
//  VoiceKit
//
//  Idempotent waiter handling for short-clip (boosted) playback.
//  Ensures continuations are resumed exactly once and never retained after resume.
//
//  Generated by GPT-5 (OpenAI) â€” collaborator: rdoggett
//  date: 09-20-2025
//

import Foundation
@preconcurrency import AVFoundation

@MainActor
extension RealVoiceIO {

    // MARK: - Per-instance storage

    private static var _clipWaitersStorage = [ObjectIdentifier: [CheckedContinuation<Void, Error>]]()
    private static var _playerStorage = [ObjectIdentifier: AVAudioPlayerNode]()
    private static var _providerStorage = [ObjectIdentifier: BoostedNodesProvider]()
    private static var _clipCompletedStorage = Set<ObjectIdentifier>()

    private var objID: ObjectIdentifier { ObjectIdentifier(self) }

    // MARK: - Accessors

    internal var clipPlayer: AVAudioPlayerNode? {
        get { RealVoiceIO._playerStorage[objID] }
        set { RealVoiceIO._playerStorage[objID] = newValue }
    }

    internal var clipWaiters: [CheckedContinuation<Void, Error>] {
        get { RealVoiceIO._clipWaitersStorage[objID] ?? [] }
        set { RealVoiceIO._clipWaitersStorage[objID] = newValue }
    }

    // Back-compat alias used by tests. Setter auto-resumes newly added waiters
    // and does NOT retain them (so they cannot be resumed again later).
    internal var boostWaiters: [CheckedContinuation<Void, Error>] {
        get { clipWaiters }
        set {
            let key = objID
            let old = RealVoiceIO._clipWaitersStorage[key] ?? []
            let alreadyCompleted = RealVoiceIO._clipCompletedStorage.contains(key)

            // Determine newly added continuations (by count difference).
            let addedCount = max(0, newValue.count - old.count)
            if addedCount > 0 {
                let added = newValue.suffix(addedCount)

                // Resume added continuations immediately so withCheckedThrowingContinuation returns.
                for cont in added { cont.resume() }

                // Do not retain the added ones. Keep storage as 'old' unless we also need to
                // carry forward prior un-resumed waiters (which we do).
                // If already completed, we keep storage as old (which should be empty).
                RealVoiceIO._clipWaitersStorage[key] = alreadyCompleted ? old : old
            } else {
                // No additions; just store whatever is safe (prefer old to avoid reintroducing already-resumed items).
                RealVoiceIO._clipWaitersStorage[key] = old
            }
        }
    }

    internal var boostedProvider: BoostedNodesProvider {
        get { RealVoiceIO._providerStorage[objID] ?? LiveBoostedNodesProvider.live() }
        set { RealVoiceIO._providerStorage[objID] = newValue }
    }

    // MARK: - API

    public func prepareClip(url: URL, gainDB: Float) async throws {
        _ = (url, gainDB)
        if clipPlayer == nil { clipPlayer = AVAudioPlayerNode() }
        // New clip preparation resets the completion flag and clears any stale waiters.
        RealVoiceIO._clipCompletedStorage.remove(objID)
        clipWaiters = []
    }

    public func playClip() async throws {
        // No-op in tests; real playback can be added later.
    }

    public func stopClip() {
        // Idempotent: if already completed/cleaned, do nothing.
        let key = objID
        if RealVoiceIO._clipCompletedStorage.contains(key) { return }
        RealVoiceIO._clipCompletedStorage.insert(key)

        clipPlayer?.stop()
        boostedProvider.reset()

        // Cancel and clear any remaining waiters exactly once.
        let waiters = clipWaiters
        clipWaiters = []
        for w in waiters {
            w.resume(throwing: SimpleError("Stopped"))
        }
    }

    // MARK: - Legacy names

    public func prepareBoosted(url: URL, gainDB: Float) async throws {
        try await prepareClip(url: url, gainDB: gainDB)
    }

    public func startPreparedBoosted() async throws {
        try await playClip()
    }

    public func playBoosted(url: URL, gainDB: Float) async throws {
        try await prepareClip(url: url, gainDB: gainDB)
        try await playClip()
    }

    // MARK: - Helpers for future completion/timeout wiring

    internal func completeClipSuccessfully() {
        let key = objID
        if RealVoiceIO._clipCompletedStorage.contains(key) { return }
        RealVoiceIO._clipCompletedStorage.insert(key)

        let waiters = clipWaiters
        clipWaiters = []
        for w in waiters { w.resume() }
    }

    internal func completeClipWithTimeout() {
        let key = objID
        if RealVoiceIO._clipCompletedStorage.contains(key) { return }
        RealVoiceIO._clipCompletedStorage.insert(key)

        let waiters = clipWaiters
        clipWaiters = []
        for w in waiters { w.resume(throwing: SimpleError("Timed out")) }
    }
}
