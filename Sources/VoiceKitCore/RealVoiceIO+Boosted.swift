//
//  RealVoiceIO+Boosted.swift
//  VoiceKit
//
//  Generated by GPT-5 (OpenAI)
//  collaborator: robert
//  date: 09-15-2025
//

import Foundation
@preconcurrency import AVFoundation
#if canImport(AVFAudio)
@preconcurrency import AVFAudio
#endif

// MARK: - Private queue actor

actor BoostQueue {
    private var scheduled = 0
    private var completed = 0
    func scheduleOne() { scheduled &+= 1 }
    func completeOne() { completed &+= 1 }
    func hasNothing() -> Bool { scheduled == 0 }
    func isDone() -> Bool { scheduled > 0 && completed >= scheduled }
    func reset() { scheduled = 0; completed = 0 }
}

@MainActor
extension RealVoiceIO {

    // MARK: - Engine wiring

    func ensureBoostEngine(format: AVAudioFormat) throws {
        if boostEngine == nil {
            let engine = AVAudioEngine()
            let player = AVAudioPlayerNode()
            let eq = AVAudioUnitEQ(numberOfBands: 0)
            engine.attach(player); engine.attach(eq)
            engine.connect(player, to: eq, format: format)
            engine.connect(eq, to: engine.mainMixerNode, format: format)
            try engine.start()
            boostEngine = engine; boostPlayer = player; boostEQ = eq
        } else if boostEngine?.isRunning == false {
            try boostEngine?.start()
        }
    }

    // MARK: - API

    public func prepareBoosted(url: URL, gainDB: Float) async throws {
        await opGate.acquire()
        defer { Task { await opGate.release() } }

        let file = try AVAudioFile(forReading: url)
        let format = file.processingFormat
        let totalFrames = AVAudioFrameCount(file.length)
        guard totalFrames > 0,
              let buffer = AVAudioPCMBuffer(pcmFormat: format, frameCapacity: totalFrames) else {
            throw SimpleError("Failed to allocate audio buffer.")
        }
        try file.read(into: buffer)
        buffer.frameLength = totalFrames
        guard buffer.frameLength > 0 else { throw SimpleError("Audio buffer empty.") }

        try ensureBoostEngine(format: format)
        boostEQ?.globalGain = max(0, min(gainDB, 24))
        guard let player = boostPlayer else { return }

        await boostQueue.scheduleOne()
        autoStartPreparedAfterTTS = true

        let playerRef = player
        let bRef = buffer
        let boostQueueRef = boostQueue

        playerRef.scheduleBuffer(bRef, at: nil, options: [], completionCallbackType: .dataPlayedBack) { _ in
            Task {
                await boostQueueRef.completeOne()
                let done = await boostQueueRef.isDone()
                if done {
                    await MainActor.run { [weak self] in
                        self?.completeBoostWaiters()
                    }
                }
            }
        }
    }

    public func startPreparedBoosted() async throws {
        if await boostQueue.hasNothing() {
            stopBoostedPlayback()
            return
        }
        guard let player = boostPlayer else {
            stopBoostedPlayback()
            return
        }
        if !autoStartPreparedAfterTTS, !player.isPlaying { player.play() }

        if await boostQueue.isDone() {
            stopBoostedPlayback()
            return
        }

        let timeout = max(0.25, config.boostedWaitTimeoutSeconds)
        await withCheckedContinuation { (cont: CheckedContinuation<Void, Never>) in
            let id = UUID()
            boostWaiters[id] = cont
            let boostQueueRef = boostQueue

            // Complete early if already done
            Task {
                let done = await boostQueueRef.isDone()
                if done {
                    await MainActor.run { [weak self] in self?.finishBoostWaiter(id: id) }
                }
            }

            // Timeout guard
            Task {
                try? await Task.sleep(nanoseconds: UInt64(timeout * 1_000_000_000))
                await MainActor.run { [weak self] in self?.finishBoostWaiter(id: id) }
            }
        }
    }

    public func playBoosted(url: URL, gainDB: Float) async throws {
        try await prepareBoosted(url: url, gainDB: gainDB)
        try await startPreparedBoosted()
    }

    // MARK: - Internals

    func completeBoostWaiters() {
        stopBoostedPlayback()
        let waiters = boostWaiters
        boostWaiters.removeAll()
        for (_, cont) in waiters { cont.resume() }
    }

    func finishBoostWaiter(id: UUID) {
        if let c = boostWaiters.removeValue(forKey: id) {
            stopBoostedPlayback()
            c.resume()
        }
    }

    func stopBoostedPlayback() {
        boostPlayer?.stop()
        boostEngine?.stop()
        boostEQ = nil
        boostPlayer = nil
        boostEngine = nil
        autoStartPreparedAfterTTS = false
        Task { await boostQueue.reset() }
    }
}
