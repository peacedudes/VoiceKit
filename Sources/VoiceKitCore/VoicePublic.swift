//
//  VoicePublic.swift
//  VoiceKit
//
//  Generated by GPT-5 (OpenAI)
//  collaborator: robert
//  date: 09-16-2025
//

import Foundation
import CoreGraphics

// MARK: - Public results and errors

/// Result of a listen() operation.
public struct VoiceResult: Sendable {
    public let transcript: String
    public let recordingURL: URL?
    public init(transcript: String, recordingURL: URL?) {
        self.transcript = transcript
        self.recordingURL = recordingURL
    }
}

/// Simple LocalizedError wrapper for user-friendly messages.
public struct SimpleError: LocalizedError, Sendable {
    public var message: String
    public init(_ message: String) { self.message = message }
    public var errorDescription: String? { message }
}

// MARK: - VoiceIO API (main-actor)

/// Primary voice I/O interface. All methods must be called on the main actor.
@MainActor
public protocol VoiceIO: AnyObject {
    // UI callbacks (main-actor)
    var onListeningChanged: ((Bool) -> Void)? { get set }
    var onTranscriptChanged: ((String) -> Void)? { get set }
    var onLevelChanged: ((CGFloat) -> Void)? { get set }
    var onTTSSpeakingChanged: ((Bool) -> Void)? { get set }
    var onTTSPulse: ((CGFloat) -> Void)? { get set }
    var onStatusMessageChanged: ((String?) -> Void)? { get set }

    // Setup
    func ensurePermissions() async throws
    func configureSessionIfNeeded() async throws

    // TTS and STT
    func speak(_ text: String) async
    func listen(timeout: TimeInterval, inactivity: TimeInterval, record: Bool) async throws -> VoiceResult

    // Short-clip SFX with optional gain
    func prepareBoosted(url: URL, gainDB: Float) async throws
    func startPreparedBoosted() async throws
    func playBoosted(url: URL, gainDB: Float) async throws

    // Stop/cancel
    func stopAll()
    func hardReset()
}

@MainActor
public extension VoiceIO {
    func prepareBoosted(url: URL) async throws { try await prepareBoosted(url: url, gainDB: 0) }
    func playBoosted(url: URL) async throws { try await playBoosted(url: url, gainDB: 0) }
    func queueSFX(url: URL, gainDB: Float = 0) async throws { try await prepareBoosted(url: url, gainDB: gainDB) }

    /// Convenience listen with context when using RealVoiceIO.
    func listen(timeout: TimeInterval,
                inactivity: TimeInterval,
                record: Bool,
                context: RecognitionContext = .init()) async throws -> VoiceResult {
        if let real = self as? RealVoiceIO {
            real.setRecognitionContext(context)
        }
        return try await listen(timeout: timeout, inactivity: inactivity, record: record)
    }
}

// MARK: - TTS models and configuration

/// Basic system voice info.
public struct TTSVoiceInfo: Identifiable, Hashable, Codable, Sendable {
    public let id: String
    public let name: String
    public let language: String
    public init(id: String, name: String, language: String) {
        self.id = id; self.name = name; self.language = language
    }
}

/// A user-tweakable voice profile.
public struct TTSVoiceProfile: Identifiable, Hashable, Codable, Sendable {
    public let id: String
    public var displayName: String
    public var rate: Float
    public var pitch: Float
    public var volume: Float
    public var isSelected: Bool
    public var isHidden: Bool
    public init(id: String, displayName: String, rate: Float, pitch: Float, volume: Float, isSelected: Bool = false, isHidden: Bool = false) {
        self.id = id; self.displayName = displayName; self.rate = rate; self.pitch = pitch; self.volume = volume
        self.isSelected = isSelected; self.isHidden = isHidden
    }
}

/// Global master controls applied to speech.
public struct TTSMasterControl: Codable, Sendable {
    public var volume: Float
    public var pitchVariation: Float
    public var rateVariation: Float
    public init(volume: Float = 1.0, pitchVariation: Float = 0.0001, rateVariation: Float = 0.0001) {
        self.volume = volume; self.pitchVariation = pitchVariation; self.rateVariation = rateVariation
    }
}

/// TTS-specific configuration and targeted speak with selected voice.
@MainActor
public protocol TTSConfigurable: AnyObject {
    func availableVoices() -> [TTSVoiceInfo]
    func setVoiceProfile(_ profile: TTSVoiceProfile)
    func getVoiceProfile(id: String) -> TTSVoiceProfile?
    func setDefaultVoiceProfile(_ profile: TTSVoiceProfile)
    func getDefaultVoiceProfile() -> TTSVoiceProfile?
    func setMasterControl(_ master: TTSMasterControl)
    func getMasterControl() -> TTSMasterControl
    func speak(_ text: String, using voiceID: String?) async
    func stopSpeakingNow()
}

// MARK: - Recognition context

/// Hints for speech recognition to improve accuracy.
public struct RecognitionContext: Sendable {
    public enum Expectation: Sendable {
        case freeform
        case name(allowed: [String])
        case number
    }
    public var expectation: Expectation
    public init(expectation: Expectation = .freeform) { self.expectation = expectation }
}

public extension RecognitionContext {
    static var numericContextualStrings: [String] {
        let digits = (0...20).map { String($0) } + ["30","40","50","60","70","80","90","100"]
        let words = ["zero","one","two","three","four","five","six","seven","eight","nine",
                     "ten","eleven","twelve","thirteen","fourteen","fifteen",
                     "sixteen","seventeen","eighteen","nineteen","twenty",
                     "thirty","forty","fifty","sixty","seventy","eighty","ninety","hundred"]
        return digits + words
    }
}

// MARK: - Operation gate

/// A minimal async gate to serialize higher-level operations.
public actor VoiceOpGate {
    private var busy = false
    public init() {}
    public func acquire() async {
        while busy { try? await Task.sleep(nanoseconds: 200_000) }
        busy = true
    }
    public func release() async { busy = false }
    public func forceClear() async { busy = false }
}
