//
//  VoiceTuningControls.swift
//  VoiceKit
//
//  Controls for tuning speed, pitch, and optional volume.
//
//  Generated by GPT-5 (OpenAI) - collaborator: rdoggett
//  date: 11-01-2025
//

import SwiftUI

@MainActor
public struct VoiceTuningControls: View {
    // Bindings
    @Binding var rate: Float
    @Binding var pitch: Float
    var volume: Binding<Float>?

    // Configuration
    let config: VoiceTuningConfig
    let labels: VoiceTuningLabels
    var onEditingChanged: ((Bool) -> Void)?

    public init(
        rate: Binding<Float>,
        pitch: Binding<Float>,
        volume: Binding<Float>? = nil,
        config: VoiceTuningConfig = .default,
        labels: VoiceTuningLabels = .default,
        onEditingChanged: ((Bool) -> Void)? = nil
    ) {
        self._rate = rate
        self._pitch = pitch
        self.volume = volume
        self.config = config
        self.labels = labels
        self.onEditingChanged = onEditingChanged
    }

    public var body: some View {
        VStack(spacing: 8) {
            // Speed / Rate (multiplier format, e.g., 1.00×)
            TunerSliderRow(
                title: labels.rate,
                systemImage: "speedometer",
                value: Binding(
                    get: { Double(rate) },
                    set: { newValue in
                        let clamped = Float(newValue).clamped(to: config.rateRange)
                        rate = config.rateStep.map { stepClamp(clamped, step: $0) } ?? clamped
                    }
                ),
                range: Double(config.rateRange.lowerBound)...Double(config.rateRange.upperBound),
                step: Double(config.rateStep ?? 0.0),
                formatted: { value in value.display(decimals: config.rateDecimals, suffix: "x") }
            )
            .onChange(of: rate) { _, _ in onEditingChanged?(false) }

            // Pitch (absolute factor, e.g., 1.00)
            TunerSliderRow(
                title: labels.pitch,
                systemImage: "waveform.path.ecg",
                value: Binding(
                    get: { Double(pitch) },
                    set: { newValue in
                        let clamped = Float(newValue).clamped(to: config.pitchRange)
                        pitch = config.pitchStep.map { stepClamp(clamped, step: $0) } ?? clamped
                    }
                ),
                range: Double(config.pitchRange.lowerBound)...Double(config.pitchRange.upperBound),
                step: Double(config.pitchStep ?? 0.0),
                formatted: { value in value.display(decimals: config.pitchDecimals) }
            )
            .onChange(of: pitch) { _, _ in onEditingChanged?(false) }

            // Volume (optional, 0.00–1.00)
            if let volume = volume, config.showVolume {
                TunerSliderRow(
                    title: labels.volume,
                    systemImage: "speaker.wave.2.fill",
                    value: Binding(
                        get: { Double(volume.wrappedValue) },
                        set: { newValue in
                            let clamped = Float(newValue).clamped(to: config.volumeRange)
                            volume.wrappedValue = config.volumeStep.map { stepClamp(clamped, step: $0) } ?? clamped
                        }
                    ),
                    range: Double(config.volumeRange.lowerBound)...Double(config.volumeRange.upperBound),
                    step: Double(config.volumeStep ?? 0.0),
                    formatted: { value in value.display(decimals: config.volumeDecimals) }
                )
                .onChange(of: volume.wrappedValue) { _, _ in onEditingChanged?(false) }
            }
        }
    }
}

// MARK: - TunerSliderRow

/// Not part of the primary public surface; most callers should use `VoiceTuningControls`.
private struct TunerSliderRow: View {
    var title: String
    var systemImage: String
    @Binding var value: Double
    var range: ClosedRange<Double>
    var step: Double
    var formatted: (Double) -> String

    init(
        title: String,
        systemImage: String,
        value: Binding<Double>,
        range: ClosedRange<Double>,
        step: Double = 0.01,
        formatted: @escaping (Double) -> String = { $0.display() }
    ) {
        self.title = title
        self.systemImage = systemImage
        self._value = value
        self.range = range
        self.step = step
        self.formatted = formatted
    }

    var body: some View {
        HStack(spacing: 8) {
            // Icon + label
            HStack(spacing: 4) {
                Image(systemName: systemImage)
                    .imageScale(.medium)
                    .font(.footnote)
                    .fontWeight(.semibold)
                    .foregroundStyle(.primary)
                Text(title)
                    .font(.footnote)
                    .foregroundStyle(.primary)
            }
            .frame(minWidth: 70, alignment: .leading)

            // Slider
            Slider(value: $value, in: range, step: step)
                .tint(.blue)

            // Numeric readout on the right
            Text(formatted(value))
                .font(.footnote)
                .monospacedDigit()
                .foregroundStyle(.primary)
                .frame(width: 52, alignment: .trailing)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }
}

// MARK: - Config and Labels
public struct VoiceTuningConfig: Sendable {
    // Visibility
    var showVolume: Bool = true

    // Ranges
    var rateRange: ClosedRange<Float>
    var pitchRange: ClosedRange<Float>
    var volumeRange: ClosedRange<Float>

    // Steps (optional; nil means free slider)
    var rateStep: Float?
    var pitchStep: Float?
    var volumeStep: Float?

    // Decimals for readouts
    var rateDecimals: Int = 2
    var pitchDecimals: Int = 2
    var volumeDecimals: Int = 2

    // Layout
    var labelWidth: CGFloat = 64
    var readoutWidth: CGFloat = 44

    // Public memberwise initializer so consumers (Demos) can construct configs.
    public init(
        showVolume: Bool = true,
        rateRange: ClosedRange<Float>,
        pitchRange: ClosedRange<Float>,
        volumeRange: ClosedRange<Float>,
        rateStep: Float? = nil,
        pitchStep: Float? = nil,
        volumeStep: Float? = nil,
        rateDecimals: Int = 2,
        pitchDecimals: Int = 2,
        volumeDecimals: Int = 2,
        labelWidth: CGFloat = 64,
        readoutWidth: CGFloat = 44
    ) { self.showVolume = showVolume; self.rateRange = rateRange; self.pitchRange = pitchRange; self.volumeRange = volumeRange; self.rateStep = rateStep; self.pitchStep = pitchStep; self.volumeStep = volumeStep; self.rateDecimals = rateDecimals; self.pitchDecimals = pitchDecimals; self.volumeDecimals = volumeDecimals; self.labelWidth = labelWidth; self.readoutWidth = readoutWidth }

    public static let `default` = VoiceTuningConfig(
        showVolume: true,
        rateRange: 0.0...1.0,       // aligns with AVSpeech rate normalization
        pitchRange: 0.5...2.0,      // conservative pitch range
        volumeRange: 0.0...1.0,
        rateStep: 0.01,
        pitchStep: 0.01,
        volumeStep: 0.01,
        rateDecimals: 2,
        pitchDecimals: 2,
        volumeDecimals: 2,
        labelWidth: 64,
        readoutWidth: 44
    )
}

public struct VoiceTuningLabels: Sendable {
    var rate: String
    var pitch: String
    var volume: String
    var rateHint: String
    var pitchHint: String
    var volumeHint: String

    public static let `default` = VoiceTuningLabels(
        rate: "Speed",
        pitch: "Pitch",
        volume: "Volume",
        rateHint: "Adjust the speaking rate",
        pitchHint: "Adjust the pitch",
        volumeHint: "Adjust the volume"
    )
}

// MARK: - Helpers

private func stepClamp(_ value: Float, step: Float) -> Float {
    guard step > 0, value.isFinite else { return value }
    let steps = (value / step).rounded()
    let snapped = steps * step
    if snapped.isFinite { return snapped }
    return value
}

#if DEBUG
@MainActor
internal struct VoiceTuningControls_Previews: PreviewProvider {
    static var previews: some View {
        Group {
            PreviewWrapper(showVolume: true)
                .previewDisplayName("With Volume")
            PreviewWrapper(showVolume: false)
                .previewDisplayName("No Volume")
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 12)
        .previewDevice("iPhone SE (3rd generation)")
    }

    private struct PreviewWrapper: View {
        @State var rate: Float = 0.55
        @State var pitch: Float = 1.0
        @State var volume: Float = 0.8
        var showVolume: Bool

        var body: some View {
            VoiceTuningControls(
                rate: $rate,
                pitch: $pitch,
                volume: showVolume ? $volume : nil,
                config: VoiceTuningConfig(
                    showVolume: showVolume,
                    rateRange: 0.0...1.0,
                    pitchRange: 0.5...2.0,
                    volumeRange: 0.0...1.0,
                    rateStep: 0.01,
                    pitchStep: 0.01,
                    volumeStep: 0.01,
                    rateDecimals: 2,
                    pitchDecimals: 2,
                    volumeDecimals: 2,
                    labelWidth: 64,
                    readoutWidth: 44
                ),
                labels: .default
            )
        }
    }
}
#endif
