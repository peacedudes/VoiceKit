//
//  ChorusLabView.swift
//  VoiceKit
//
//  Generated by GPT-5 (OpenAI) — collaborator: rdoggett
//  date: 09-17-2025
//

import SwiftUI
import VoiceKit
#if canImport(UIKit)
import UIKit
#endif
#if canImport(AppKit)
import AppKit
#endif
// MARK: - Design tokens
private enum Metrics {
    enum Padding {
        static let headerV: CGFloat = 4
        static let iosH: CGFloat = 16
        static let macH: CGFloat = 32
    }
    enum Layout {
        static let inlineHintSpacer: CGFloat = 50
        static let actualTimeMinWidth: CGFloat = 60
        static let timingCellWidth: CGFloat = 40
    }
    enum Controls {
        static let sliderStep: Double = 0.01
    }
    enum Defaults {
        // Match initializer types: rate is Double; pitch/volume are Float
        static let rate: Double = 0.55
        static let pitch: Float = 1.0
        static let volume: Float = 1.0
    }
    enum Buttons {
        // Stabilize Play/Stop label swap
        static let playTextMinWidth: CGFloat = 100
        static let horizontalPad: CGFloat = 14
        static let verticalPad: CGFloat = 4
    }
    enum Calibration {
        static let tolerance: Double = 0.05
        static let maxIterations: Int = 3
    }
    enum Timing {
        static let targetSecondsRange: ClosedRange<Double> = 1.0...20.0
        static let targetSecondsStep: Double = 0.25
    }
    enum Adjustments {
        static let slowRange: Double = 0.75
        static let speedRange: ClosedRange<Double> = 0.05...2.0
        static let pitchOffsetRange: ClosedRange<Double> = -0.9...0.9
    }
    enum Pitch {
        static let clampLo: Float = 0.5
        static let clampHi: Float = 2.0
    }
}
@MainActor
internal struct ChorusLabView: View {
    @State private var selectedProfiles: [TTSVoiceProfile] = []
    @State private var pitch: Float = 1.0
    @State private var rate: Float = 0.55
    @State private var customText: String = "Six swift ships."
    @State private var targetSeconds: Double = 3.0
    @State private var isCalibrating: Bool = false
    @State private var calibrationTask: Task<Void, Never>?
    @State private var lastDurationByID: [String: TimeInterval] = [:]
    @State private var lastChorusSeconds: Double?
    @State private var isPlaying: Bool = false
    @State private var calibratingVoiceID: String?
    // Baseline profiles and global adjustments for chorus-wide tweaks
    @State private var baseProfiles: [TTSVoiceProfile] = []
    @State private var rateScale: Double = 1.0       // Multiplies baseline rate
    @State private var pitchOffset: Double = 0.0     // Adds to baseline pitch

    // Tuner presentation
    @State private var showTuner = false
    @State private var tunerSelection: String?
    @State private var tunerEngine = RealVoiceIO()
    @State private var editingIndex: Int?
    // Copy-to-clipboard feedback
    @State private var didCopy: Bool = false

    // MARK: - Internal proxies for logic extension (keep @State private)
    // These expose controlled access for helpers in ChorusLabView+Logic.swift.
    internal var vk_selectedProfiles: [TTSVoiceProfile] {
        get { selectedProfiles } set { selectedProfiles = newValue }
    }
    internal var vk_baseProfiles: [TTSVoiceProfile] {
        get { baseProfiles } set { baseProfiles = newValue }
    }
    internal var vk_rateScale: Double {
        get { rateScale } set { rateScale = newValue }
    }
    internal var vk_pitchOffset: Double {
        get { pitchOffset } set { pitchOffset = newValue }
    }
    internal var vk_showTuner: Bool {
        get { showTuner } set { showTuner = newValue }
    }
    internal var vk_tunerSelection: String? {
        get { tunerSelection } set { tunerSelection = newValue }
    }
    internal var vk_tunerEngine: RealVoiceIO {
        get { tunerEngine } set { tunerEngine = newValue }
    }
    internal var vk_editingIndex: Int? {
        get { editingIndex } set { editingIndex = newValue }
    }

    // Internal constant proxies for logic in another file (keeps Metrics private)
    internal var _defaultsRate: Double { Metrics.Defaults.rate }
    internal var _defaultsPitch: Float { Metrics.Defaults.pitch }
    internal var _defaultsVolume: Float { Metrics.Defaults.volume }
    internal var _pitchClampLo: Float { Metrics.Pitch.clampLo }
    internal var _pitchClampHi: Float { Metrics.Pitch.clampHi }
    internal var _slowRange: Double { Metrics.Adjustments.slowRange }

    // Calibration constants for logic in another file
    internal var _calTolerance: Double { Metrics.Calibration.tolerance }
    internal var _calMaxIterations: Int { Metrics.Calibration.maxIterations }

    // Additional state proxies used by play/stop/sync helpers
    internal var vk_isPlaying: Bool {
        get { isPlaying } set { isPlaying = newValue }
    }
    internal var vk_isCalibrating: Bool {
        get { isCalibrating } set { isCalibrating = newValue }
    }
    internal var vk_calibrationTask: Task<Void, Never>? {
        get { calibrationTask } set { calibrationTask = newValue }
    }
    internal var vk_lastDurationByID: [String: TimeInterval] {
        get { lastDurationByID } set { lastDurationByID = newValue }
    }
    internal var vk_lastChorusSeconds: Double? {
        get { lastChorusSeconds } set { lastChorusSeconds = newValue }
    }
    internal var vk_calibratingVoiceID: String? {
        get { calibratingVoiceID } set { calibratingVoiceID = newValue }
    }
    internal var vk_customText: String {
        get { customText } set { customText = newValue }
    }
    // Avoid colliding with SwiftUI's synthesized _targetSeconds backing storage
    internal var vk_targetSeconds: Double {
        get { targetSeconds } set { targetSeconds = newValue }
    }

    // iOS-only: edit mode toggling for List reordering
    #if os(iOS)
    @Environment(\.editMode)
    private var editMode
    #endif
    // Dependencies for testability and reuse:
    // - voicesProvider: supplies available system voices
    // - engineFactory: creates RealVoiceIO instances for chorus engines, calibration, and tuner
    let voicesProvider: any SystemVoicesProvider
    let engineFactory: () -> RealVoiceIO
    let chorus: VoiceChorus

    /// Create the Chorus Lab view with injectable dependencies.
    /// - Parameters:
    ///   - voicesProvider: Source of system voices (defaults to SystemVoicesCache).
    ///   - engineFactory: Factory for engines (defaults to RealVoiceIO()).
    init(
        voicesProvider: any SystemVoicesProvider = DefaultSystemVoicesProvider(),
        engineFactory: @escaping () -> RealVoiceIO = { RealVoiceIO() }
    ) {
        self.voicesProvider = voicesProvider
        self.engineFactory = engineFactory
        // VoiceChorus.Engine == any TTSConfigurable & VoiceIO.
        self.chorus = VoiceChorus(makeEngine: {
            engineFactory() as (any TTSConfigurable & VoiceIO)
        })
    }

    var body: some View {
        VStack {
            // Fixed control area
            VStack {
                // Title
                Text("Chorus Lab")
                    .font(.largeTitle)

                // Text input moved to the top
                ZStack(alignment: .topLeading) {
                    ZStack(alignment: .topLeading) {
                        if customText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                            Text("""
                                Add voices with +
                                Press Play to hear your chorus
                                Tune Goal, Rate, and Pitch to match
                                """)
                                .font(.footnote)
                                .foregroundStyle(.secondary)
                                .multilineTextAlignment(.leading)
                                .lineLimit(nil)
                                .padding(.top, 8)
                                .padding(.leading, 6)
                                .padding(.trailing, 8)
                                .allowsHitTesting(false)
                        }
                        TextEditor(text: $customText)
                            .frame(height: 72, alignment: .topLeading) // ~3 lines, fixed
                            .scrollIndicators(.automatic)
                            .border(Color.gray, width: 0.5)
                            .accessibilityLabel("Chorus text")
                            .accessibilityHint("Enter the phrase the chorus will speak")
                            // VoiceOver will read the text content by default; the hint clarifies purpose.
                            .accessibilityAddTraits(.isStaticText)
                    }
                }

                targetTimeRow()
                globalAdjustmentsSection()
                // Place Play/Stop (and Synchronize all) below sliders and above the Voices section.
                actionButtonsRow()
            }
            .padding()

            // Pinned header for the voices list (does not scroll)
            HStack {
                // Left-aligned header over the name column
                Text("Voices")
                    .font(.title3)
                    .fontWeight(.semibold)
                    .frame(maxWidth: .infinity, alignment: .leading)

                // Trailing action: simple Add button
                Button {
                    presentAddVoice()
                } label: {
                    // Professionals commonly use an icon-only + in toolbars/headers
                    Image(systemName: "plus")
                }
                .accessibilityLabel("Add voice")
                #if os(macOS)
                .buttonStyle(.bordered)
                .controlSize(.small)
                .help("Add")
                #else
                .buttonStyle(.plain)
                #endif

                // Copy-to-clipboard: generate one-liners to recreate the current chorus.
                Button {
                    copyChorusSetup()
                    withAnimation(.spring(response: 0.25, dampingFraction: 0.8)) {
                        didCopy = true
                    }
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.9) {
                        withAnimation(.easeOut(duration: 0.35)) {
                            didCopy = false
                        }
                    }
                } label: {
                    Image(systemName: "doc.on.doc")
                }
                .accessibilityLabel("Copy setup")
                .help("Copy Swift one-liners to recreate these voices")
                #if os(macOS)
                .buttonStyle(.bordered)
                .controlSize(.small)
                #else
                .buttonStyle(.plain)
                #endif
            }
            .overlay(alignment: .topTrailing) {
                if didCopy {
                    HStack(spacing: 6) {
                        Image(systemName: "checkmark.circle.fill")
                        Text("Copied to Clipboard")
                            .font(.caption2)
                            .fontWeight(.semibold)
                    }
                    .foregroundStyle(.green)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(Capsule().fill(Color.green.opacity(0.12)))
                    .transition(.scale.combined(with: .opacity))
                    .offset(y: -24)
                }
            }
            .padding(.vertical, 4)
            #if os(macOS)
            // On macOS, give the "Voices" header comparable horizontal margins to the control area.
            .padding(.horizontal, Metrics.Padding.macH)
            #else
            .padding(.horizontal, Metrics.Padding.iosH)
            #endif
            .padding(.bottom, 0)
            // List area (enables swipe actions)
            List {
                selectedVoicesSection()
            }
            .listStyle(.plain)
            // Subtle animation for row add/remove or reordering
            .animation(.easeInOut(duration: 0.20), value: selectedProfiles.count)
            #if os(macOS)
            // On macOS, add horizontal padding so the list aligns with the rest of the view.
            .padding(.horizontal, Metrics.Padding.macH)
            #endif
        }
        .sheet(isPresented: $showTuner) {
            // Wrap in a padded container so margins are guaranteed even if VoiceChooserView is edge-to-edge.
            VStack {
                VoiceChooserView(
                    tts: tunerEngine,
                    selectedID: $tunerSelection,
                    onChoose: {
                        applyTunerSelection()
                        showTuner = false
                    },
                    onCancel: {
                        showTuner = false
                    }
                )
            }
            .padding(.horizontal, 16)
            .frame(minWidth: 420, minHeight: 520)
            // iOS-only sheet presentation tweaks
            #if os(iOS)
            .presentationDetents([.large])
            .presentationDragIndicator(.visible)
            #endif
        }
        .onAppear {
            // Keep baseline in sync on first load.
            if baseProfiles.isEmpty, !selectedProfiles.isEmpty {
                baseProfiles = selectedProfiles
            }
            // Pre-seed two voices so the chorus is playable immediately.
            // Seed only once on first appear.
            if selectedProfiles.isEmpty {
                seedInitialVoices(count: 2)
                // Pure transform: re-derive effective profiles from baseline + sliders
                selectedProfiles = ChorusMath.applyAdjustments(
                    baseProfiles: baseProfiles,
                    rateScale: rateScale,
                    pitchOffset: pitchOffset
                )
            }
        }
        // Safety net: when rows are added/removed, realign baseline and re-apply.
        .onChange(of: selectedProfiles.count) { _, _ in
            baseProfiles = selectedProfiles
            selectedProfiles = ChorusMath.applyAdjustments(
                baseProfiles: baseProfiles,
                rateScale: rateScale,
                pitchOffset: pitchOffset
            )
        }
    }

    // New: Selected voices section with edit/remove
    @ViewBuilder
    private func selectedVoicesSection() -> some View {
        if selectedProfiles.isEmpty {
            Text("Tap “Add voice…” to choose voices and tune pitch/volume.")
                .foregroundStyle(.secondary)
                .padding(.vertical, 8)
        } else {
            ForEach($selectedProfiles, id: \.id) { profile in
                // Unwrap binding element for read-only UI usage in this row
                let profileValue = profile.wrappedValue
                ChorusLabSelectedVoiceRow(
                    name: resolvedName(for: profileValue.id),
                    rate: profileValue.rate,
                    pitch: profileValue.pitch,
                    volume: profileValue.volume,
                    duration: lastDurationByID[profileValue.id],
                    isCalibrating: calibratingVoiceID == profileValue.id,
                    timingCellWidth: Metrics.Layout.timingCellWidth
                )
                .contentShape(Rectangle())
                .onTapGesture {
                    if let idx = selectedProfiles.firstIndex(where: { $0.id == profileValue.id }) {
                        presentEditVoice(index: idx)
                    }
                }
                .swipeActions(edge: .trailing, allowsFullSwipe: true) {
                    // Put Sync first so full-swipe defaults to Sync (safer than Delete).
                    Button {
                        // Temporarily disabled: we’ll rewire to a nonmutating async flow in the next step.
                    } label: {
                        Label("Sync", systemImage: "arrow.clockwise")
                    }
                    .tint(.blue)
                    .accessibilityLabel("Synchronize this voice")
                    .accessibilityHint("Calibrate this voice to the target time")

                    Button(role: .destructive) {
                        // Remove from the effective list and sync baseline so
                        // future global adjustments don’t resurrect this row.
                        let removedID = profileValue.id
                        if let idx = selectedProfiles.firstIndex(where: { $0.id == removedID }) {
                            selectedProfiles.remove(at: idx)
                        }
                        lastDurationByID.removeValue(forKey: removedID)
                        baseProfiles = selectedProfiles
                        // Pure transform: re-derive effective profiles from baseline + sliders
                        selectedProfiles = ChorusMath.applyAdjustments(
                            baseProfiles: baseProfiles,
                            rateScale: rateScale,
                            pitchOffset: pitchOffset
                        )
                    } label: { Label("Delete", systemImage: "trash") }
                    .accessibilityLabel("Delete voice")
                }
            }
            // Attach reordering to the ForEach so it works on all platforms.
        }
    }

    // MARK: - Calibration (synchronize rates)
    private func synchronizeRates() {
        guard !selectedProfiles.isEmpty else { return }
        isCalibrating = true
        let phrase = customText
        let prevScale = rateScale
        // Cancel any in-flight calibration task
        calibrationTask?.cancel()
        calibrationTask = Task { @MainActor in
            // Use a dedicated engine for measurement to avoid interfering with the chorus engine
            let io = engineFactory()
            defer {
                isCalibrating = false
                calibrationTask = nil
                // After calibration, refresh selectedProfiles from baseline with current global sliders
                // First, restore the user's speed scale and ensure baseline reflects any calibrated rate changes:
                rateScale = prevScale
                baseProfiles = selectedProfiles
                // Apply global scaling/offset to produce effective profiles:
                var updated: [TTSVoiceProfile] = []
                updated.reserveCapacity(baseProfiles.count)
                for var profile in baseProfiles {
                    // Amplified relative mapping (all Double to match TTSVoiceProfile.rate):
                    // - If rateScale > 1, move toward 1.0 by a fraction of headroom.
                    // - If rateScale < 1, move toward 0.0 by a fraction of current value.
                    let base: Double = profile.rate
                    let newRate: Double = {
                        if rateScale >= 1.0 {
                            let factor = max(0.0, min(1.0, rateScale - 1.0)) // 1.0→2.0 maps to 0…1
                            return (base + (1.0 - base) * factor).clamped(to: 0.0...1.0)
                        } else {
                            let factor = max(0.0, min(1.0, (1.0 - rateScale) / Metrics.Adjustments.slowRange)) // 1.0→0.25 maps to 0…1
                            return (base - base * factor).clamped(to: 0.0...1.0)
                        }
                    }()
                    profile.rate = newRate
                    profile.pitch = (profile.pitch + Float(pitchOffset)).clamped(to: Metrics.Pitch.clampLo...Metrics.Pitch.clampHi)
                    updated.append(profile)
                }
                selectedProfiles = updated
            }
            // Normalize global speed during calibration to avoid compounding while fitting
            rateScale = 1.0

            for i in selectedProfiles.indices {
                if Task.isCancelled { return }
                // Ensure the IO has the current profile before measuring
                let voiceID = selectedProfiles[i].id
                calibratingVoiceID = voiceID
                await Task.yield()
                io.setVoiceProfile(selectedProfiles[i])

                // Calibrate this voice to the target duration
                let result = await VoiceTempoCalibrator.fitRate(
                    io: io,
                    voiceID: voiceID,
                    phrase: phrase,
                    targetSeconds: targetSeconds,
                    tolerance: Metrics.Calibration.tolerance,
                    maxIterations: Metrics.Calibration.maxIterations
                )
                // Update the stored and baseline profile with the new rate and last measured duration
                selectedProfiles[i].rate = result.finalRate
                lastDurationByID[voiceID] = result.measured
                // Reflect progress live in the header “actual time” display
                lastChorusSeconds = result.measured
                // Give the UI a chance to refresh during calibration
                await Task.yield()
            }
            calibratingVoiceID = nil
        }
    }

    // MARK: - Header row components
    @ViewBuilder
    private func targetTimeRow() -> some View {
        HStack(spacing: 8) {
            Text("Target Time")
                .font(.footnote)
                .lineLimit(1)
                .layoutPriority(1)
            Text(String(format: "%.2fs", targetSeconds))
                .monospacedDigit()
                .foregroundStyle(.secondary)
            Stepper(value: $targetSeconds, in: Metrics.Timing.targetSecondsRange, step: Metrics.Timing.targetSecondsStep) {
                EmptyView()
            }
            .labelsHidden()
            .controlSize(.mini)
            .accessibilityLabel("Target time")
            .accessibilityHint("Adjust the target duration in seconds")

            // Group the actual time elements for a clear VoiceOver announcement
            // VoiceOver will read the value; the label clarifies context.
            Spacer()
            HStack(spacing: 6) {
                if isPlaying {
                    ProgressView().controlSize(.mini)
                }
                Text(lastChorusSeconds.map { $0.asSeconds2f } ?? "—s")
                    .monospacedDigit()
                    .foregroundStyle(.secondary)
                    .lineLimit(1)
            }
            .frame(minWidth: Metrics.Layout.actualTimeMinWidth, alignment: .trailing)
            .accessibilityLabel("Actual time")
            .accessibilityValue(lastChorusSeconds.map { $0.asSeconds2f } ?? "Not available")
        }
        .padding(.horizontal)
        .padding(.bottom, Metrics.Padding.headerV)
    }

    @ViewBuilder
    private func actionButtonsRow() -> some View {
        ChorusLabActionRowView(
            isPlaying: $isPlaying,
            isCalibrating: $isCalibrating,
            hasSelection: !selectedProfiles.isEmpty,
            onPlay: {
                // Inline to avoid calling a mutating helper from an immutable context
                Task { @MainActor in
                    isPlaying = true
                    let t0 = Date()
                    await chorus.sing(customText, withVoiceProfiles: selectedProfiles)
                    let elapsed = Date().timeIntervalSince(t0)
                    lastChorusSeconds = elapsed
                    isPlaying = false
                }
            },
            onStop: {
                // Inline immediate stop logic
                calibrationTask?.cancel()
                calibrationTask = nil
                isCalibrating = false
                chorus.stop()
                if isPlaying { isPlaying = false }
            },
            onSync: { synchronizeRates() }
        )
        .padding(.bottom, Metrics.Padding.headerV)
    }

    @ViewBuilder
    private func globalAdjustmentsSection() -> some View {
        ChorusLabGlobalAdjustmentsView(
            rateScale: $rateScale,
            pitchOffset: $pitchOffset,
            speedRange: Metrics.Adjustments.speedRange,
            pitchOffsetRange: Metrics.Adjustments.pitchOffsetRange,
            sliderStep: Metrics.Controls.sliderStep,
            onChange: {
                // Pure transform: re-derive effective profiles from baseline + sliders
                selectedProfiles = ChorusMath.applyAdjustments(
                    baseProfiles: baseProfiles,
                    rateScale: rateScale,
                    pitchOffset: pitchOffset
                )
            }
        )
    }

    // Extracted views are now in Labs/Components as internal types:
    // - ChorusLabActionRowView
    // - ChorusLabGlobalAdjustmentsView
    // - ChorusLabSelectedVoiceRow

    // Synchronize a single voice (row-level). Runs a focused calibration for that index.
    // (moved: synchronizeVoice -> ChorusLabView+Logic.swift)

    // (moved: startChorus -> ChorusLabView+Logic.swift)

    // Cancel any in-flight calibration and stop the chorus immediately.
    // (moved: stopAll -> ChorusLabView+Logic.swift)

    // Use system voices (RealVoiceIO no longer exposes availableVoices()).
    @MainActor
    func availableVoices() -> [TTSVoiceInfo] {
        voicesProvider.all()
            .sorted { $0.name.localizedCaseInsensitiveCompare($1.name) == .orderedAscending }
    }

    /// Seed initial voices so users can play the chorus immediately.
    /// Picks `count` random distinct system voices from the current language and nudges pitch to differentiate.
    private func seedInitialVoices(count: Int = 2) {
        // Filter to current language base code (e.g., "en").
        let baseLang: String = {
            let tag = Locale.preferredLanguages.first ?? Locale.current.identifier
            if let dash = tag.firstIndex(of: "-") { return String(tag[..<dash]).lowercased() }
            return tag.lowercased()
        }()
        let list = availableVoices().filter {
            let lang = $0.language
            let code: String = {
                if let dash = lang.firstIndex(of: "-") { return String(lang[..<dash]).lowercased() }
                return lang.lowercased()
            }()
            return code == baseLang
        }
        guard !list.isEmpty else { return }

        // Random without replacement
        let slice = Array(list.shuffled().prefix(max(0, count)))
        var picks: [TTSVoiceProfile] = []
        let pitchOffsets: [Float] = [-0.05, 0.05, 0.1, -0.1]

        for (index, voice) in slice.enumerated() {
            var profile = TTSVoiceProfile(id: voice.id, rate: Metrics.Defaults.rate, pitch: Metrics.Defaults.pitch, volume: Metrics.Defaults.volume)
            if index < pitchOffsets.count {
                profile.pitch = (profile.pitch + pitchOffsets[index]).clamped(to: Metrics.Pitch.clampLo...Metrics.Pitch.clampHi)
            }
            picks.append(profile)
        }
        // Establish baseline and effective selections
        baseProfiles = picks
        selectedProfiles = picks
    }

    // MARK: - Tuner integration
    /// Present the voice tuner to add a new voice.
    /// Seeds the tuner with a random voice from the user's preferred language.
    private func presentAddVoice() {
        editingIndex = nil
        // Use the injected engine factory for testability and consistency.
        tunerEngine = engineFactory()
        // Prefer a random voice from the user’s preferred language; fall back to any.
        let baseLang: String = {
            let tag = Locale.preferredLanguages.first ?? Locale.current.identifier
            if let dash = tag.firstIndex(of: "-") { return String(tag[..<dash]).lowercased() }
            return tag.lowercased()
        }()
        let sameLang = availableVoices().filter {
            let lang = $0.language
            let code: String = {
                if let dash = lang.firstIndex(of: "-") { return String(lang[..<dash]).lowercased() }
                return lang.lowercased()
            }()
            return code == baseLang
        }
        let pool = sameLang.isEmpty ? availableVoices() : sameLang
        if let pick = pool.randomElement() {
            tunerSelection = pick.id
            let seed = TTSVoiceProfile(id: pick.id, rate: Metrics.Defaults.rate, pitch: Metrics.Defaults.pitch, volume: Metrics.Defaults.volume)
            tunerEngine.setVoiceProfile(seed)
            tunerEngine.setDefaultVoiceProfile(seed)
        } else {
            tunerSelection = nil
        }
        showTuner = true
    }

    private func presentEditVoice(index: Int) {
        guard selectedProfiles.indices.contains(index) else { return }
        editingIndex = index
        tunerEngine = engineFactory()
        // Seed tuner with current profile
        let prof = selectedProfiles[index]
        tunerEngine.setVoiceProfile(prof)
        tunerEngine.setDefaultVoiceProfile(prof) // ensure sliders reflect the current row exactly
        tunerSelection = prof.id
        showTuner = true
    }

    private func applyTunerSelection() {
        guard let id = tunerSelection else { return }
        // Prefer the specific profile returned by the tuner engine; fall back to its default;
        // finally, seed a mid profile if neither is available yet.
        var tuned: TTSVoiceProfile? = tunerEngine.getVoiceProfile(id: id)
        if tuned == nil, let def = tunerEngine.getDefaultVoiceProfile() {
            tuned = TTSVoiceProfile(id: id, rate: def.rate, pitch: def.pitch, volume: def.volume)
        }
        if tuned == nil {
            tuned = TTSVoiceProfile(id: id, rate: Metrics.Defaults.rate, pitch: Metrics.Defaults.pitch, volume: Metrics.Defaults.volume)
        }
        guard let tuned else { return }
        if let idx = editingIndex, selectedProfiles.indices.contains(idx) {
            // Editing an existing row updates only that row
            selectedProfiles[idx] = tuned
        } else {
            // Always allow duplicates when adding
            selectedProfiles.append(tuned)
        }
        // Clear edit state
        editingIndex = nil
        tunerSelection = nil
        // Keep baseline aligned to effective list, then re-apply globals
        baseProfiles = selectedProfiles
        // Re-apply global adjustments so effective profiles reflect sliders
        selectedProfiles = ChorusMath.applyAdjustments(
            baseProfiles: baseProfiles,
            rateScale: rateScale,
            pitchOffset: pitchOffset
        )
    }

    // (moved: resolvedName, applyGlobalAdjustments -> ChorusLabView+Logic.swift)

    // (moved: copyChorusSetup, copyToClipboard -> ChorusLabView+Logic.swift)
}

// MARK: - Snippet building (single source of truth)
// Internal so tests can call it via @testable import VoiceKitUI.
internal func makeChorusSnippet(for profiles: [TTSVoiceProfile]) -> String {
    guard !profiles.isEmpty else { return "" }

    let body = profiles
        .map { "    " + $0.initStr() }
        .joined(separator: ",\n")

    return """
    // VoiceKit chorus setup (generated by Chorus Lab)
    import VoiceKit

    let chorusProfiles = [
    \(body)
    ]
    // Use with VoiceChorus: await VoiceChorus().sing("Your phrase", withVoiceProfiles: chorusProfiles)
    """
}

internal struct ChorusLabView_Previews: PreviewProvider {
    internal static var previews: some View {
        Group {
            #if os(macOS)
            ChorusLabView()
                .frame(width: 520, height: 820) // taller, narrower for Mac preview
                .previewDisplayName("macOS")
            #else
            ChorusLabView()
                .previewDisplayName("iOS")
            #endif
        }
    }
}

// MARK: - Formatting helpers
private extension Double {
    // Two-decimal seconds with ASCII 's' suffix
    var asSeconds2f: String { String(format: "%.2fs", self) }
}

// MARK: - Unit-testable helpers
/// Helpers for chorus tuning logic. Pure and unit-testable.
internal enum ChorusMath {
    /// Compute an adjusted rate from a baseline rate and a global rate scBale.
    /// Mapping is amplified relative to the base:
    /// - rateScale > 1.0 moves toward 1.0 by a fraction of headroom (1.0 - base)
    /// - rateScale < 1.0 pulls toward 0.0 by a fraction of the base value
    /// Values are clamped to 0...1 to match TTSVoiceProfile.rate expectations.
    /// - Parameters:
    ///   - baseRate: The original voice rate, in 0...1.
    ///   - rateScale: Global multiplier. 1.0 = unchanged; >1.0 speeds up; <1.0 slows down.
    ///   - slowRange: Denominator for mapping 1.0→0.x into t:0...1 (prevents over-slowing too quickly).
    /// - Returns: New rate in 0...1.
    static func adjustedRate(baseRate: Double, rateScale: Double, slowRange: Double) -> Double {
        if rateScale >= 1.0 {
            // Map 1.0→2.0 into t:0...1 and push toward 1.0 by headroom
            let factor = max(0.0, min(1.0, rateScale - 1.0))
            return (baseRate + (1.0 - baseRate) * factor).clamped(to: 0.0...1.0)
        } else {
            // Map 1.0→0.25 into t:0...1 and pull toward 0.0 by fraction of base
            let factor = max(0.0, min(1.0, (1.0 - rateScale) / slowRange))
            return (baseRate - baseRate * factor).clamped(to: 0.0...1.0)
        }
    }

    /// Apply global rate scale and pitch offset to a set of baseline profiles.
    /// - Parameters:
    ///   - baseProfiles: The baseline chorus (not mutated).
    ///   - rateScale: Global rate multiplier (see adjustedRate).
    ///   - pitchOffset: Global offset added to pitch, then clamped.
    /// - Returns: New profiles array with adjusted rate and pitch.
    static func applyAdjustments(
        baseProfiles: [TTSVoiceProfile],
        rateScale: Double,
        pitchOffset: Double
    ) -> [TTSVoiceProfile] {
        var updated: [TTSVoiceProfile] = []
        updated.reserveCapacity(baseProfiles.count)
        for var profile in baseProfiles {
            profile.rate = adjustedRate(baseRate: profile.rate, rateScale: rateScale, slowRange: Metrics.Adjustments.slowRange)
            profile.pitch = (profile.pitch + Float(pitchOffset)).clamped(to: Metrics.Pitch.clampLo...Metrics.Pitch.clampHi)
            updated.append(profile)
        }
        return updated
    }
}

/// Seconds formatting helpers (pure; suitable for tests).
internal enum SecondsFormatter {
    static func twoDecimals(_ seconds: Double) -> String { String(format: "%.2fs", seconds) }
}

// MARK: - Injected dependencies
/// Abstraction over the source of system voices, to enable testing and reuse.
internal protocol SystemVoicesProvider {
    @MainActor
    func all() -> [TTSVoiceInfo]
}

/// Default provider backed by SystemVoicesCache.
internal struct DefaultSystemVoicesProvider: SystemVoicesProvider {
    @MainActor
    func all() -> [TTSVoiceInfo] {
        SystemVoicesCache.all()
    }
}

fileprivate extension TTSVoiceProfile {
    // Build a Swift initializer string that reproduces this profile exactly.
    // Example:
    // TTSVoiceProfile(id: "com.apple.speech.synthesis.voice.Alex", rate: 0.550, pitch: 1.000, volume: 1.000)
    func arg(_ name: String, _ value: String) -> String { "\(name): \(value)" }
    func num<N: BinaryFloatingPoint>(_ name: String, _ value: N) -> String { arg(name, String(format: "%.3f", Double(value))) }
    func initStr() -> String { """
        TTSVoiceProfile(\(arg("id", "\"\(id)\"")),
                \(num("rate", rate)), \(num("pitch", pitch)), \(num("volume", volume)))
        """
    }
}
