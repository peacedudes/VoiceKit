//
//  VoicePickerView.swift
//  VoiceKit
//
//  Generated by GPT-5 (OpenAI) â€” collaborator: rdoggett
//  date: 09-20-2025
//

import SwiftUI
import Foundation
import VoiceKitCore
import AVFoundation

public struct VoiceProfilesFile: Codable {
    public var defaultVoiceID: String?
    public var master: TTSMasterControl
    public var profilesByID: [String: TTSVoiceProfile]
    public var activeVoiceIDs: [String]
    public var hiddenVoiceIDs: [String]

    public init(defaultVoiceID: String? = nil,
                master: TTSMasterControl = .init(),
                profilesByID: [String: TTSVoiceProfile] = [:],
                activeVoiceIDs: [String] = [],
                hiddenVoiceIDs: [String] = []) {
        self.defaultVoiceID = defaultVoiceID
        self.master = master
        self.profilesByID = profilesByID
        self.activeVoiceIDs = activeVoiceIDs
        self.hiddenVoiceIDs = hiddenVoiceIDs
    }

    private struct ProfileDTO: Codable {
        var id: String
        var rate: Double
        var pitch: Float
        var volume: Float
    }

    private struct MasterDTO: Codable {
        var rateVariation: Float
        var pitchVariation: Float
        var volume: Float
        init(_ m: TTSMasterControl) {
            rateVariation = m.rateVariation; pitchVariation = m.pitchVariation; volume = m.volume
        }
        func make() -> TTSMasterControl {
            TTSMasterControl(rateVariation: rateVariation, pitchVariation: pitchVariation, volume: volume)
        }
    }

    enum CodingKeys: String, CodingKey { case defaultVoiceID, master, profilesByID, activeVoiceIDs, hiddenVoiceIDs }

    public init(from decoder: Decoder) throws {
        let c = try decoder.container(keyedBy: CodingKeys.self)
        defaultVoiceID = try c.decodeIfPresent(String.self, forKey: .defaultVoiceID)
        master = try c.decode(MasterDTO.self, forKey: .master).make()
        activeVoiceIDs = try c.decodeIfPresent([String].self, forKey: .activeVoiceIDs) ?? []
        hiddenVoiceIDs = try c.decodeIfPresent([String].self, forKey: .hiddenVoiceIDs) ?? []
        let dict = try c.decodeIfPresent([String: ProfileDTO].self, forKey: .profilesByID) ?? [:]
        profilesByID = dict.reduce(into: [:]) { acc, kv in
            acc[kv.key] = TTSVoiceProfile(
                id: kv.value.id,
                rate: kv.value.rate,
                pitch: kv.value.pitch,
                volume: kv.value.volume
            )
        }
    }

    public func encode(to encoder: Encoder) throws {
        var c = encoder.container(keyedBy: CodingKeys.self)
        try c.encodeIfPresent(defaultVoiceID, forKey: .defaultVoiceID)
        try c.encode(MasterDTO(master), forKey: .master)
        try c.encode(activeVoiceIDs, forKey: .activeVoiceIDs)
        try c.encode(hiddenVoiceIDs, forKey: .hiddenVoiceIDs)
        let dict = profilesByID.mapValues { ProfileDTO(id: $0.id, rate: $0.rate, pitch: $0.pitch, volume: $0.volume) }
        try c.encode(dict, forKey: .profilesByID)
    }
}

@MainActor
public final class VoiceProfilesStore: ObservableObject {
    @Published public var defaultVoiceID: String?
    @Published public var master: TTSMasterControl = .init()
    @Published public var profilesByID: [String: TTSVoiceProfile] = [:]
    @Published public var activeVoiceIDs: Set<String> = []
    @Published public var hiddenVoiceIDs: Set<String> = []

    private let fileURL: URL

    public init(filename: String = "voices.json") {
        let appSupport = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first
            ?? FileManager.default.temporaryDirectory
        let dir = appSupport.appendingPathComponent("VoiceIO", isDirectory: true)
        try? FileManager.default.createDirectory(at: dir, withIntermediateDirectories: true)
        self.fileURL = dir.appendingPathComponent(filename)
        load()
    }

    public func load() {
        guard let data = try? Data(contentsOf: fileURL) else { return }
        if let decoded = try? JSONDecoder().decode(VoiceProfilesFile.self, from: data) {
            self.defaultVoiceID = decoded.defaultVoiceID
            self.master = decoded.master
            self.profilesByID = decoded.profilesByID
            self.activeVoiceIDs = Set(decoded.activeVoiceIDs)
            self.hiddenVoiceIDs = Set(decoded.hiddenVoiceIDs)
        }
    }

    public func save() {
        let payload = VoiceProfilesFile(defaultVoiceID: defaultVoiceID, master: master, profilesByID: profilesByID, activeVoiceIDs: Array(activeVoiceIDs), hiddenVoiceIDs: Array(hiddenVoiceIDs))
        if let data = try? JSONEncoder().encode(payload) {
            try? data.write(to: fileURL, options: [.atomic])
        }
    }

    public func profile(for info: TTSVoiceInfo) -> TTSVoiceProfile {
        if let p = profilesByID[info.id] { return p }
        let p = TTSVoiceProfile(id: info.id, rate: 0.55, pitch: 1.0, volume: 0.9)
        profilesByID[info.id] = p
        return p
    }

    public func setProfile(_ p: TTSVoiceProfile) { profilesByID[p.id] = p }
    public func isActive(_ id: String) -> Bool { activeVoiceIDs.contains(id) }
    public func toggleActive(_ id: String) { if activeVoiceIDs.contains(id) { activeVoiceIDs.remove(id) } else { activeVoiceIDs.insert(id) }; save() }
    public func isHidden(_ id: String) -> Bool { hiddenVoiceIDs.contains(id) }
    public func setHidden(_ id: String, _ hidden: Bool) { if hidden { hiddenVoiceIDs.insert(id) } else { hiddenVoiceIDs.remove(id) }; save() }
}

// Public lightweight protocol tests can adopt to provide deterministic voice lists.
@preconcurrency public protocol VoiceListProvider {
    func availableVoices() -> [TTSVoiceInfo]
}

@MainActor
public final class VoicePickerViewModel: ObservableObject {
    @Published public var voices: [TTSVoiceInfo] = []
    @Published public var showHidden: Bool = false

    public enum LanguageFilter: Hashable { case current, all }
    @Published public var languageFilter: LanguageFilter = .current

    private var previewTask: Task<Void, Never>?
    private var masterPreviewDebounce: Task<Void, Never>?

    public let tts: TTSConfigurable
    public let store: VoiceProfilesStore

    private let allowSystemVoicesOverride: Bool?
    private var allowSystemVoicesEffective: Bool = false

    public init(tts: TTSConfigurable, store: VoiceProfilesStore, allowSystemVoices: Bool? = nil) {
        self.tts = tts
        self.store = store
        self.allowSystemVoicesOverride = allowSystemVoices

        Task { @MainActor in
            if let override = allowSystemVoices {
                self.allowSystemVoicesEffective = override
            } else {
                self.allowSystemVoicesEffective = await VoiceKitTestMode.allowSystemVoiceQueries()
            }
            self.refreshAvailableVoices()
            self.bootstrapDefaultsIfNeeded()
            self.applyToTTS()
        }
    }

    public func refreshAvailableVoices() {
        // Deterministic, user-friendly order: primary by display name, then by language.
        // This keeps tests stable (e.g., ["Alpha","Beta"]) and is predictable in UI.
        voices = resolveVoices().sorted { a, b in
            if a.name == b.name { return a.language < b.language }
            return a.name < b.name
        }
    }

    private func resolveVoices() -> [TTSVoiceInfo] {
        // If TTS provides a deterministic list (tests), prefer it in all modes.
        if let provider = tts as? VoiceListProvider {
            return provider.availableVoices()
        }

        // If system queries are explicitly disallowed, return empty rather than a placeholder.
        if allowSystemVoicesEffective == false {
            return []
        }

        // Otherwise, query system voices.
        return AVSpeechSynthesisVoice.speechVoices().map {
            TTSVoiceInfo(id: $0.identifier, name: $0.name, language: $0.language)
        }
    }

    // MARK: - Language/Filtering

    private func languageCodePrefix() -> String {
        let tag = Locale.preferredLanguages.first ?? Locale.current.identifier
        return tag.split(separator: "-").first.map(String.init)?.lowercased() ?? "en"
    }

    public var currentLanguageDisplayName: String {
        let code = languageCodePrefix()
        return Locale.current.localizedString(forLanguageCode: code)?.capitalized ?? code.uppercased()
    }

    public var filteredVoices: [TTSVoiceInfo] {
        let base: [TTSVoiceInfo]
        switch languageFilter {
        case .all: base = voices
        case .current:
            let pref = languageCodePrefix()
            base = voices.filter { $0.language.lowercased().hasPrefix(pref) }
        }
        return base.filter { info in showHidden || !store.isHidden(info.id) }
    }

    // MARK: - Bootstrap / Apply

    private func bootstrapDefaultsIfNeeded() {
        // Create profiles for any resolved voices so UI sliders can bind immediately.
        for v in voices { _ = store.profile(for: v) }
        store.save()

        // Validate existing default against the current voice list; clear if invalid.
        if let def = store.defaultVoiceID {
            let valid = voices.contains(where: { $0.id == def })
            if !valid {
                store.defaultVoiceID = nil
            }
        }

        // Choose a sensible default if missing or was just cleared.
        if store.defaultVoiceID == nil {
            if let first = filteredVoices.first ?? voices.first {
                store.defaultVoiceID = first.id
                store.save()
            }
        }
    }

    public func applyToTTS() {
        for (_, p) in store.profilesByID { tts.setVoiceProfile(p) }
        if let id = store.defaultVoiceID, let p = store.profilesByID[id] { tts.setDefaultVoiceProfile(p) }
        tts.setMasterControl(store.master)
    }

    public func setDefaultVoice(id: String) { store.defaultVoiceID = id; store.save(); applyToTTS() }

    public func updateProfile(_ p: TTSVoiceProfile) {
        store.setProfile(p); store.save()
        if store.defaultVoiceID == p.id { tts.setDefaultVoiceProfile(p) } else { tts.setVoiceProfile(p) }
        tts.setMasterControl(store.master)
    }

    public func updateMaster(_ m: TTSMasterControl, previewKind: String? = nil) {
        store.master = m; store.save(); tts.setMasterControl(m)
        if let kind = previewKind {
            masterPreviewDebounce?.cancel()
            masterPreviewDebounce = Task { [weak self] in
                guard let self else { return }
                try? await Task.sleep(nanoseconds: 160_000_000)
                if let (id, profile) = self.pickPreviewVoice() {
                    let phrase = self.samplePhrase(for: profile, suffix: kind)
                    self.playPreview(phrase: phrase, voiceID: id)
                }
            }
        }
    }

    // Select a preview voice safely. If none are available, return nil and skip playback.
    private func pickPreviewVoice() -> (String, TTSVoiceProfile)? {
        if let fav = store.defaultVoiceID, let p = store.profilesByID[fav] {
            return (fav, p)
        }

        let candidates = filteredVoices.isEmpty ? voices : filteredVoices
        if let info = candidates.randomElement() {
            return (info.id, store.profile(for: info))
        }

        return nil
    }

    public func samplePhrase(for profile: TTSVoiceProfile, suffix: String = "") -> String {
        let who = AVSpeechSynthesisVoice(identifier: profile.id)?.name ?? "Voice"
        let base = "My name is \(who). This is what my voice sounds like"
        return suffix.isEmpty ? base + "." : base + " " + suffix + "."
    }

    public func playPreview(phrase: String, voiceID: String) {
        previewTask?.cancel()
        previewTask = Task { [tts] in
            if Task.isCancelled { return }
            await tts.speak(phrase, using: voiceID)
        }
    }

    public func stopPreview() { previewTask?.cancel(); masterPreviewDebounce?.cancel() }
}

// MARK: - View

public struct VoicePickerView: View {
    @ObservedObject private var store: VoiceProfilesStore
    @StateObject private var vm: VoicePickerViewModel

    @MainActor
    public init(tts: TTSConfigurable) {
        let s = VoiceProfilesStore()
        _store = ObservedObject(wrappedValue: s)
        _vm = StateObject(wrappedValue: VoicePickerViewModel(tts: tts, store: s))
    }

    @MainActor
    public init(tts: TTSConfigurable, store: VoiceProfilesStore) {
        _store = ObservedObject(wrappedValue: store)
        _vm = StateObject(wrappedValue: VoicePickerViewModel(tts: tts, store: store))
    }

    public var body: some View {
        NavigationView {
            Form {
                Section("Master") {
                    HStack {
                        Label("Volume", systemImage: "speaker.wave.2.fill")
                        Slider(
                            value: Binding(
                                get: { Double(store.master.volume) },
                                set: { newVal in
                                    vm.updateMaster(
                                        TTSMasterControl(rateVariation: store.master.rateVariation,
                                                         pitchVariation: store.master.pitchVariation,
                                                         volume: Float(newVal)),
                                        previewKind: "at volume \(String(format: "%.2f", newVal))"
                                    )
                                }
                            ),
                            in: 0...2, step: 0.01
                        )
                        Text(String(format: "%.2f", store.master.volume))
                            .monospacedDigit().foregroundStyle(.secondary)
                            .frame(width: 52, alignment: .trailing)
                    }
                    HStack {
                        Label("Pitch range", systemImage: "waveform")
                        Slider(
                            value: Binding(
                                get: { Double(store.master.pitchVariation) },
                                set: { newVal in
                                    vm.updateMaster(
                                        TTSMasterControl(rateVariation: store.master.rateVariation,
                                                         pitchVariation: Float(newVal),
                                                         volume: store.master.volume),
                                        previewKind: "with pitch range \(String(format: "%.3f", newVal))"
                                    )
                                }
                            ),
                            in: 0...0.2, step: 0.001
                        )
                        Text(String(format: "%.3f", store.master.pitchVariation))
                            .monospacedDigit().foregroundStyle(.secondary)
                            .frame(width: 62, alignment: .trailing)
                    }
                    HStack {
                        Label("Speed range", systemImage: "speedometer")
                        Slider(
                            value: Binding(
                                get: { Double(store.master.rateVariation) },
                                set: { newVal in
                                    vm.updateMaster(
                                        TTSMasterControl(rateVariation: Float(newVal),
                                                         pitchVariation: store.master.pitchVariation,
                                                         volume: store.master.volume),
                                        previewKind: "with speed range \(String(format: "%.3f", newVal))"
                                    )
                                }
                            ),
                            in: 0...0.2, step: 0.001
                        )
                        Text(String(format: "%.3f", store.master.rateVariation))
                            .monospacedDigit().foregroundStyle(.secondary)
                            .frame(width: 62, alignment: .trailing)
                    }
                }

                Section("Voices") {
                    HStack {
                        Picker("Filter", selection: $vm.languageFilter) {
                            Text(vm.currentLanguageDisplayName).tag(VoicePickerViewModel.LanguageFilter.current)
                            Text("All").tag(VoicePickerViewModel.LanguageFilter.all)
                        }
                        .pickerStyle(.segmented)
                        Toggle("Show hidden", isOn: $vm.showHidden).toggleStyle(.switch)
                    }

                    if vm.filteredVoices.isEmpty {
                        Text("No system voices available for this filter.")
                            .foregroundStyle(.secondary)
                    } else {
                        ForEach(vm.filteredVoices, id: \.id) { info in
                            VoiceRow(
                                info: info,
                                profile: store.profile(for: info),
                                isActive: store.isActive(info.id),
                                isFavorite: store.defaultVoiceID == info.id,
                                isHidden: store.isHidden(info.id),
                                onToggleActive: { store.toggleActive(info.id) },
                                onFavorite: { vm.setDefaultVoice(id: info.id) },
                                onHide: { store.setHidden(info.id, true) },
                                onUnhide: { store.setHidden(info.id, false) },
                                onChange: { updated, suffix in
                                    vm.updateProfile(updated)
                                    vm.playPreview(phrase: vm.samplePhrase(for: updated, suffix: suffix), voiceID: info.id)
                                },
                                onTapRow: {
                                    let p = store.profile(for: info)
                                    vm.playPreview(phrase: vm.samplePhrase(for: p), voiceID: info.id)
                                }
                            )
                        }
                    }
                }
            }
            .navigationTitle("Voices")
        }
        .onDisappear { vm.stopPreview() }
    }
}

private struct VoiceRow: View {
    let info: TTSVoiceInfo
    @State var profile: TTSVoiceProfile
    let isActive: Bool
    let isFavorite: Bool
    let isHidden: Bool
    let onToggleActive: () -> Void
    let onFavorite: () -> Void
    let onHide: () -> Void
    let onUnhide: () -> Void
    let onChange: (TTSVoiceProfile, String) -> Void
    let onTapRow: () -> Void

    @State private var expanded = false

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack(spacing: 12) {
                Button(action: onToggleActive) {
                    Image(systemName: isActive ? "checkmark.circle.fill" : "circle")
                        .foregroundStyle(isActive ? AnyShapeStyle(.tint) : AnyShapeStyle(.secondary))
                        .imageScale(.large)
                }
                .buttonStyle(.plain)

                VStack(alignment: .leading) {
                    HStack {
                        Text(AVSpeechSynthesisVoice(identifier: profile.id)?.name ?? info.name)
                            .font(.headline)
                        if isHidden {
                            Text("Hidden").font(.caption2)
                                .padding(.horizontal, 6).padding(.vertical, 2)
                                .background(.gray.opacity(0.2))
                                .clipShape(RoundedRectangle(cornerRadius: 4))
                        }
                    }
                    Text("\(info.language)").font(.caption).foregroundStyle(.secondary)
                }

                Spacer()

                Button(action: onFavorite) {
                    Image(systemName: isFavorite ? "star.fill" : "star")
                        .foregroundStyle(isFavorite ? AnyShapeStyle(.tint) : AnyShapeStyle(.secondary))
                        .imageScale(.large)
                }
                .buttonStyle(.plain)

                Button { withAnimation { expanded.toggle() } } label: {
                    Image(systemName: expanded ? "chevron.up" : "chevron.down").foregroundStyle(.secondary)
                }
                .buttonStyle(.plain)
            }
            .contentShape(Rectangle())
            .onTapGesture { onTapRow() }
            .swipeActions(edge: .trailing, allowsFullSwipe: false) {
                if isHidden {
                    Button("Unhide") { onUnhide() }
                        .tint(.blue)
                } else {
                    Button("Hide") { onHide() }
                        .tint(.red)
                }
            }

            if expanded {
                VStack(spacing: 10) {
                    HStack {
                        Text("Speed").frame(width: 70, alignment: .leading)
                        Slider(
                            value: Binding(
                                get: { Double(profile.rate) },
                                set: { newValue in
                                    profile.rate = Double(newValue)
                                    onChange(
                                        profile,
                                        "at speed \(String(format: "%.2f", profile.rate))"
                                    )
                                }
                            ),
                            in: 0...1,
                            step: 0.01
                        )
                        Text(String(format: "%.2f", profile.rate))
                            .monospacedDigit()
                            .foregroundStyle(.secondary)
                            .frame(width: 52, alignment: .trailing)
                    }
                    HStack {
                        Text("Pitch").frame(width: 70, alignment: .leading)
                        Slider(
                            value: Binding(
                                get: { Double(profile.pitch) },
                                set: { newValue in
                                    profile.pitch = Float(newValue)
                                    onChange(
                                        profile,
                                        "at pitch \(String(format: "%.2f", profile.pitch))"
                                    )
                                }
                            ),
                            in: 0.5...2.0,
                            step: 0.01
                        )
                        Text(String(format: "%.2f", profile.pitch))
                            .monospacedDigit()
                            .foregroundStyle(.secondary)
                            .frame(width: 52, alignment: .trailing)
                    }
                    HStack {
                        Text("Volume").frame(width: 70, alignment: .leading)
                        Slider(
                            value: Binding(
                                get: { Double(profile.volume) },
                                set: { newValue in
                                    profile.volume = Float(newValue)
                                    onChange(
                                        profile,
                                        "at volume \(String(format: "%.2f", profile.volume))"
                                    )
                                }
                            ),
                            in: 0...1,
                            step: 0.01
                        )
                        Text(String(format: "%.2f", profile.volume))
                            .monospacedDigit()
                            .foregroundStyle(.secondary)
                            .frame(width: 52, alignment: .trailing)
                    }
                }
                .padding(.top, 4)
            }
        }
        .padding(.vertical, 6)
    }
}

struct VoicePickerView_Previews: PreviewProvider {
    static var previews: some View { VoicePickerView(tts: RealVoiceIO()) }
}
