//
//  VoiceChooserViewModel.swift
//  VoiceKitUI
//
//  Minimal ViewModel to support VoiceChooserView and UI tests.
//  Manages available voices, filtering, store updates, and simple preview.
//
//  Generated by GPT-5.1 (OpenAI) - collaborator: rdoggett
//  date: 11-20-2025
//

import SwiftUI
import AVFoundation
import Foundation
import VoiceKit

@MainActor
public final class VoiceChooserViewModel: ObservableObject {
    // MARK: - Language and filtering

    public enum LanguageFilter: Equatable {
        case current
        case all
        case specific(String) // base code like "en"
    }

    // Inputs
    private let tts: TTSConfigurable
    private let allowSystemVoices: Bool
    @ObservedObject public private(set) var store: VoiceProfilesStore

    // Published state
    /// Full list of available voices (unfiltered).
    @Published public private(set) var voices: [TTSVoiceInfo] = []
    @Published public var languageFilter: LanguageFilter = .current
    @Published public var showHidden: Bool = false

    /// Language options derived from `voices` (base code + display name).
    @Published public private(set) var languageOptions: [(code: String, name: String)] = []
    /// Enhanced-quality system voice identifiers (optional; empty on CI / under XCTest).
    @Published public private(set) var enhancedVoiceIDs: Set<String> = []
    /// Loading flag for UI (e.g., while enumerating or refreshing voices).
    @Published public private(set) var isLoading: Bool = false
    /// Last measured preview duration in seconds, if available.
    @Published public private(set) var lastPreviewSeconds: Double?

    // Preview task
    private var previewTask: Task<Void, Never>?
    private var isPreviewing = false

    public init(tts: TTSConfigurable,
                store: VoiceProfilesStore,
                allowSystemVoices: Bool = false) {
        self.tts = tts
        self.store = store
        self.allowSystemVoices = allowSystemVoices
    }

    // MARK: - Voice loading

    /// Deterministic refresh when a provider is present; otherwise optional system cache.
    public func refreshAvailableVoices() {
        isLoading = true

        if let provider = tts as? VoiceListProvider {
            let list = provider.availableVoices()
            self.voices = list
            self.languageOptions = computeLanguageOptions(from: list)
            self.enhancedVoiceIDs = []
            self.isLoading = false
            bootstrapProfilesIfNeeded()
            return
        }

        if allowSystemVoices {
            _ = SystemVoicesCache.refresh()
            let list = SystemVoicesCache.all()
            self.voices = list
            self.languageOptions = computeLanguageOptions(from: list)

            // Gate enhanced voice detection under XCTest to avoid AV/XPC lookup noise in CI.
            let isXCTest = ProcessInfo.processInfo.environment["XCTestConfigurationFilePath"] != nil
            if !isXCTest {
                self.enhancedVoiceIDs = Set(
                    AVSpeechSynthesisVoice.speechVoices()
                        .filter { $0.quality == .enhanced }
                        .map { $0.identifier }
                )
            } else {
                self.enhancedVoiceIDs = []
            }

            self.isLoading = false
            bootstrapProfilesIfNeeded()
        } else {
            self.voices = []
            self.languageOptions = []
            self.enhancedVoiceIDs = []
            self.isLoading = false
        }
    }

    // Filtered view
    public var filteredVoices: [TTSVoiceInfo] {
        let byLanguage: [TTSVoiceInfo] = {
            switch languageFilter {
            case .all:
                return voices
            case .current:
                let base = currentLanguageCode()
                return voices.filter { baseLanguageCode($0.language).lowercased() == base }
            case .specific(let code):
                let base = code.lowercased()
                return voices.filter { baseLanguageCode($0.language).lowercased() == base }
            }
        }()
        if showHidden { return byLanguage }
        let hidden = Set(store.hiddenVoiceIDs)
        return byLanguage.filter { !hidden.contains($0.id) }
    }

    // MARK: - Store and TTS sync

    public func updateProfile(_ profile: TTSVoiceProfile) {
        store.setProfile(profile)
    }

    public func setDefaultVoice(id: String) {
        store.defaultVoiceID = id
    }

    // Transitional convenience: prefer 'tuning' from UI code.
    // Proxies to store.master until full rename.
    public func updateTuning(_ tuning: Tuning, previewKind: String? = nil) {
        store.tuning = tuning
    }

    public func applyToTTS() {
        tts.setTuning(store.tuning)
        for profile in store.profilesByID.values {
            tts.setVoiceProfile(profile)
        }
        if let defID = store.defaultVoiceID,
           let def = store.profilesByID[defID] {
            tts.setDefaultVoiceProfile(def)
        }
    }

    /// Best-effort lookup of the current profile from the TTS engine itself.
    /// Useful when another client (like ChorusLab) has already tuned a profile
    /// on the engine and we want the chooser to start from those values.
    public func profileFromTTS(id: String) -> TTSVoiceProfile? {
        if let fromID = tts.getVoiceProfile(id: id) {
            return fromID
        }
        if let def = tts.getDefaultVoiceProfile(), def.id == id {
            return def
        }
        return nil
    }

    // MARK: - Samples and previews

    public func samplePhrase(for profile: TTSVoiceProfile, suffix: String? = nil) -> String {
        let name = systemDisplayName(for: profile.id) ?? "Voice"
        var phrase = "My name is \(name)."
        if let suffix { phrase += " \(suffix)" }
        return phrase
    }

    public func playPreview(phrase: String, voiceID: String) {
        stopPreview()
        isPreviewing = true
        previewTask = Task { [weak self] in
            guard let self else { return }
            let start = Date()
            await tts.speak(phrase, using: voiceID)
            let elapsed = Date().timeIntervalSince(start)
            await MainActor.run {
                self.lastPreviewSeconds = elapsed
                self.isPreviewing = false
            }
        }
    }

    public func stopPreview() {
        previewTask?.cancel()
        previewTask = nil
        if let io = tts as? VoiceIO {
            io.stopAll()
        }
        isPreviewing = false
    }

    // MARK: - Language helpers used by the view

    public var currentLanguageName: String {
        let code = currentLanguageCode()
        return Locale.current.localizedString(forLanguageCode: code)?.capitalized ?? code.uppercased()
    }

    private func languageDisplayName(for code: String) -> String {
        Locale.current.localizedString(forLanguageCode: code)?.capitalized ?? code.uppercased()
    }

    private func computeLanguageOptions(from list: [TTSVoiceInfo]) -> [(code: String, name: String)] {
        let codes = Set(list.map { baseLanguageCode($0.language).lowercased() })
        let mapped = codes.map { ($0, languageDisplayName(for: $0)) }
        return mapped.sorted { $0.1.localizedCaseInsensitiveCompare($1.1) == .orderedAscending }
    }

    // MARK: - Helpers

    private func baseLanguageCode(_ tag: String) -> String {
        if let dash = tag.firstIndex(of: "-") { return String(tag[..<dash]) }
        return tag
    }

    private func currentLanguageCode() -> String {
        let tag = Locale.preferredLanguages.first ?? Locale.current.identifier
        return baseLanguageCode(tag).lowercased()
    }

    private func bootstrapProfilesIfNeeded() {
        for voice in voices { _ = store.profile(for: voice) }
        if store.defaultVoiceID == nil, let first = voices.first {
            store.defaultVoiceID = first.id
        }
    }

    private func systemDisplayName(for id: String) -> String? {
        AVSpeechSynthesisVoice(identifier: id)?.name
    }
}
