//
//  VoiceChooserView.swift
//  VoiceKit
//
//  A focused UI to pick a system voice and tune its settings (rate, pitch, volume)
//  with immediate audio feedback.
//
//  Generated by GPT-5.1 (OpenAI) - collaborator: rdoggett
//  date: 11-20-2025
//

import SwiftUI
import AVFoundation
import VoiceKit

@MainActor
public struct VoiceChooserView: View {
    @StateObject private var viewModel: VoiceChooserViewModel

    // Optional chooser wiring
    private var onChoose: (() -> Void)?
    private var onCancel: (() -> Void)?
    @Binding private var selectedIDBinding: String?

    @State private var selectedID: String?
    @State private var workingProfile: TTSVoiceProfile?
    @State private var selectedIDString: String = ""

    // Debounced auto-preview when sliders change.
    @State private var sliderPreviewTask: Task<Void, Never>?

    // Language filtering UI (view-model owns the data)
    @State private var showFullLanguagePicker: Bool = false

    // Map ViewModel.LanguageFilter <-> String tags for the compact picker.
    // Reserved tags: "_current" and "_all"; otherwise use base language codes like "en", "es".
    private var languageSelectionBinding: Binding<String> {
        Binding(
            get: { tag(for: viewModel.languageFilter) },
            set: { viewModel.languageFilter = filter(forTag: $0) }
        )
    }

    private func tag(for filter: VoiceChooserViewModel.LanguageFilter) -> String {
        switch filter {
        case .current: return "_current"
        case .all: return "_all"
        case .specific(let code): return code.lowercased()
        }
    }

    private func filter(forTag tag: String) -> VoiceChooserViewModel.LanguageFilter {
        switch tag {
        case "_current": return .current
        case "_all": return .all
        default: return .specific(tag.lowercased())
        }
    }

    // MARK: - Initializers

    // Standard use
    public init(tts: TTSConfigurable, store: VoiceProfilesStore) {
        _viewModel = StateObject(
            wrappedValue: VoiceChooserViewModel(
                tts: tts,
                store: store,
                allowSystemVoices: true
            )
        )
        self.onChoose = nil
        self.onCancel = nil
        self._selectedIDBinding = .constant(nil)
    }

    // Chooser mode
    public init(tts: TTSConfigurable,
                store: VoiceProfilesStore,
                selectedID: Binding<String?>,
                onChoose: (() -> Void)? = nil,
                onCancel: (() -> Void)? = nil) {
        _viewModel = StateObject(
            wrappedValue: VoiceChooserViewModel(
                tts: tts,
                store: store,
                allowSystemVoices: true
            )
        )
        self.onChoose = onChoose
        self.onCancel = onCancel
        self._selectedIDBinding = selectedID
    }

    // Convenience: ephemeral store (no persistence). Keeps API simple for apps that don't need a store.
    public init(tts: TTSConfigurable) {
        let store = VoiceProfilesStore()
        _viewModel = StateObject(
            wrappedValue: VoiceChooserViewModel(
                tts: tts,
                store: store,
                allowSystemVoices: true
            )
        )
        self.onChoose = nil
        self.onCancel = nil
        self._selectedIDBinding = .constant(nil)
    }

    // Convenience chooser: ephemeral store + binding for selection.
    public init(
        tts: TTSConfigurable,
        selectedID: Binding<String?>,
        onChoose: (() -> Void)? = nil,
        onCancel: (() -> Void)? = nil
    ) {
        let store = VoiceProfilesStore()
        _viewModel = StateObject(
            wrappedValue: VoiceChooserViewModel(
                tts: tts,
                store: store,
                allowSystemVoices: true
            )
        )
        self.onChoose = onChoose
        self.onCancel = onCancel
        self._selectedIDBinding = selectedID
    }

    // MARK: - Body

    public var body: some View {
        NavigationStack {
            VStack(spacing: 10) {
                // Compact language control: starts as "English voices" and expands one-way to full picker.
                VoiceLanguagePicker(
                    showFullLanguagePicker: $showFullLanguagePicker,
                    selection: languageSelectionBinding,
                    currentLanguageName: viewModel.currentLanguageName,
                    languageOptions: viewModel.languageOptions,
                    onSetCurrent: {
                        viewModel.languageFilter = .current
                    },
                    onExpandToAll: {
                        showFullLanguagePicker = true
                        viewModel.languageFilter = .all
                    }
                )

                // Voice picker (wheel on iOS, default on macOS/tvOS)
                Picker("Voice", selection: $selectedIDString) {
                    ForEach(viewModel.filteredVoices, id: \.id) { info in
                        // Mark enhanced voices with a star to disambiguate variants.
                        let name = viewModel.enhancedVoiceIDs.contains(info.id) ? "\(info.name)*" : info.name
                        Text("\(name) · \(info.language)").tag(info.id)
                    }
                }
                .pickerStyle(pickerStyle)
                .frame(maxHeight: pickerMaxHeight)
                .padding(.horizontal, 20)
                .onChange(of: selectedIDString) { _, newID in
                    selectedID = newID.isEmpty ? nil : newID
                    // Reflect selection to external binding if provided
                    selectedIDBinding = selectedID
                    loadWorkingProfile()
                    // Apply current tuning and speak to differentiate variants immediately.
                    commitChanges()
                    previewSpeak(samplePhrase())
                }

                // Centered Sample between pickers and sliders
                HStack {
                    Spacer()
                    Button {
                        commitChanges()
                        previewSpeak(samplePhrase())
                    } label: {
                        Label("Sample", systemImage: "play.fill")
                    }
                    // Live preview duration badge
                    if let secs = viewModel.lastPreviewSeconds {
                        Text(secs.formatted(suffix: "s"))
                            .font(.footnote)
                            .monospacedDigit()
                            .foregroundStyle(.primary)
                            .padding(.leading, 8)
                    }
                    Spacer()
                }

                // Lightweight indicator that voices are still loading
                if viewModel.isLoading && viewModel.voices.isEmpty {
                    ProgressView()
                        .controlSize(.small)
                        .padding(.top, -8)
                }

                // Single set of sliders for the selected voice
                if let profile = workingProfile {
                    VStack(spacing: 14) {
                        // Unified tuning controls (Speed, Pitch, Volume) using shared component
                        VoiceTuningControls(
                            rate: Binding<Float>(
                                get: { Float(workingProfile?.rate ?? profile.rate) },
                                set: { newVal in
                                    workingProfile?.rate = Double(newVal.clamped(to: 0.0...1.0))
                                    scheduleSliderPreview()
                                }
                            ),
                            pitch: Binding<Float>(
                                get: { Float(workingProfile?.pitch ?? profile.pitch) },
                                set: { newVal in
                                    workingProfile?.pitch = newVal.clamped(to: 0.5...2.0)
                                    scheduleSliderPreview()
                                }
                            ),
                            volume: Binding<Float>(
                                get: { Float(workingProfile?.volume ?? profile.volume) },
                                set: { newVal in
                                    workingProfile?.volume = newVal.clamped(to: 0.0...1.0)
                                    scheduleSliderPreview()
                                }
                            ),
                            config: VoiceTuningConfig(
                                showVolume: true,
                                rateRange: 0.0...1.0,
                                pitchRange: 0.5...2.0,
                                volumeRange: 0.0...1.0,
                                rateStep: 0.01,
                                pitchStep: 0.01,
                                volumeStep: 0.01
                            ),
                            labels: .default
                        )

                        // Chooser actions (only when callbacks are provided)
                        if onChoose != nil || onCancel != nil {
                            HStack(spacing: 12) {
                                if let onCancel {
                                    Button(role: .cancel) { onCancel() }
                                    label: { Text("Cancel") }
                                }
                                Spacer()
                                if let onChoose {
                                    Button {
                                        // Ensure external binding is updated
                                        selectedIDBinding = selectedID
                                        commitChanges()
                                        onChoose()
                                    } label: { Text("Choose") }
                                        .buttonStyle(.borderedProminent)
                                }
                            }
                            .padding(.top, 2)
                        }
                    }
                    .padding(.horizontal, 20)
                } else {
                    Text("Select a voice to tune").foregroundStyle(.secondary)
                }
                Spacer()
            }
            .navigationTitle("Voice Chooser")
            .onAppear {
                viewModel.refreshAvailableVoices()
                seedSelectionFromInitialState()
            }
        }
    }

    // MARK: - Selection / profile wiring

    /// Seed the initial selection from the external binding or store defaults.
    private func seedSelectionFromInitialState() {
        // 1) External binding, if valid
        if selectedID == nil,
           let bound = selectedIDBinding,
           viewModel.voices.contains(where: { $0.id == bound }) {
            selectedID = bound
        }

        // 2) Store default, if present and valid
        if selectedID == nil,
           let def = viewModel.store.defaultVoiceID,
           viewModel.voices.contains(where: { $0.id == def }) {
            selectedID = def
        }

        // 3) Fallback: first filtered voice
        if selectedID == nil {
            selectedID = viewModel.filteredVoices.first?.id
        }

        selectedIDString = selectedID ?? ""
        loadWorkingProfile()
    }

    private func loadWorkingProfile() {
        guard let id = selectedID,
              let info = viewModel.voices.first(where: { $0.id == id }) else {
            workingProfile = nil
            return
        }
        // Start with any stored profile...
        var profile = viewModel.store.profile(for: info)
        // ...prefer a profile that is already in the store’s profilesByID
        if let seeded = viewModel.store.profilesByID[id] {
            profile = seeded
        }
        // ...and finally prefer a profile already applied on the TTS engine
        if let engineProfile = viewModel.profileFromTTS(id: id) {
            profile = engineProfile
        }
        workingProfile = profile
    }

    private func commitChanges() {
        guard let profile = workingProfile else { return }
        viewModel.updateProfile(profile)
        viewModel.applyToTTS()
    }

    /// Schedule a short, debounced preview after slider changes.
    /// Keeps interaction responsive while avoiding hammering TTS.
    private func scheduleSliderPreview() {
        // Ensure we have a selected voice and working profile first.
        guard selectedID != nil, workingProfile != nil else { return }

        // Cancel any in-flight preview debounce.
        sliderPreviewTask?.cancel()

        sliderPreviewTask = Task { @MainActor in
            // Small delay so we only fire after the user pauses briefly.
            try? await Task.sleep(nanoseconds: 180_000_000) // ~0.18s
            if Task.isCancelled { return }
            commitChanges()
            previewSpeak(samplePhrase())
        }
    }

    // MARK: - Speaking

    private func samplePhrase() -> String {
        if let profile = workingProfile {
            return viewModel.samplePhrase(for: profile)
        }
        return "The quick brown fox jumps over the lazy dog."
    }

    private func previewSpeak(_ text: String) {
        guard let id = selectedID else { return }
        viewModel.playPreview(phrase: text, voiceID: id)
    }

    // MARK: - Picker style helpers

#if os(iOS)
    private var pickerStyle: some PickerStyle { WheelPickerStyle() }
    private var pickerMaxHeight: CGFloat? { 180 }
#else
    private var pickerStyle: some PickerStyle { DefaultPickerStyle() }
    private var pickerMaxHeight: CGFloat? { nil }
#endif
}

// MARK: - Preview
internal struct VoiceChooserView_Previews: PreviewProvider {
    internal static var previews: some View {
        VoiceChooserPreviewContainer()
    }
}

private struct VoiceChooserPreviewContainer: View {
    @State private var pickedVoiceID: String?
    private let tts: TTSConfigurable = RealVoiceIO()

    var body: some View {
        let chooser = VoiceChooserView(
            tts: tts,
            selectedID: $pickedVoiceID,
            onChoose: {},
            onCancel: {}
        )
        chooser
            .frame(minWidth: 375, minHeight: 520) // "SE-friendly" preview size
    }
}
