//
//  VoiceChorusPlayground.swift
//  VoiceKit
//
//  Generated by GPT-5 (OpenAI) — collaborator: rdoggett
//  date: 09-17-2025
//

import SwiftUI
import VoiceKitCore

@MainActor
struct VoiceChorusPlayground: View {
    @State private var selectedProfiles: [TTSVoiceProfile] = []
    @State private var pitch: Float = 1.0
    @State private var rate: Float = 0.55
    @State private var customText: String = "Six swift ships."
    @State private var targetSeconds: Double = 3.0
    @State private var isCalibrating: Bool = false
    @State private var calibrationTask: Task<Void, Never>? = nil
    @State private var lastDurationByID: [String: TimeInterval] = [:]
    @State private var lastChorusSeconds: Double? = nil
    @State private var isPlaying: Bool = false
    @State private var calibratingVoiceID: String? = nil
    // Baseline profiles and global adjustments for chorus-wide tweaks
    @State private var baseProfiles: [TTSVoiceProfile] = []
    @State private var rateScale: Double = 1.0       // Multiplies baseline rate
    @State private var pitchOffset: Double = 0.0     // Adds to baseline pitch

    // Tuner presentation
    @State private var showTuner = false
    @State private var tunerSelection: String? = nil
    @State private var tunerEngine = RealVoiceIO()
    @State private var editingIndex: Int? = nil

    @Environment(\.editMode) private var editMode
    // VoiceChorus.Engine == any TTSConfigurable & VoiceIO.
    // Some toolchains require an explicit local to help existential inference.
    let chorus = VoiceChorus(makeEngine: {
        let engine = RealVoiceIO()
        return engine as (any TTSConfigurable & VoiceIO)
    })

    var body: some View {
        VStack {
            // Fixed control area
            VStack {
                // Title
                Text("Chorus Playground")
                    .font(.largeTitle)

                // Text input moved to the top
                ZStack(alignment: .topLeading) {
                    ZStack(alignment: .topLeading) {
                        if customText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                            Text("Add voices with +\nPress Play to hear your chorus\nTune Goal, Rate, and Pitch to match")
                                .font(.footnote)
                                .foregroundStyle(.secondary)
                                .multilineTextAlignment(.leading)
                                .lineLimit(nil)
                                .padding(.top, 8)
                                .padding(.leading, 6)
                                .padding(.trailing, 8)
                                .allowsHitTesting(false)
                        }
                        TextEditor(text: $customText)
                            .frame(height: 72, alignment: .topLeading) // ~3 lines, fixed
                            .scrollIndicators(.automatic)
                            .border(Color.gray, width: 0.5)
                    }
                }

                targetTimeRow()
                actionButtonsRow()
                globalAdjustmentsSection()
            }
            .padding()

            // Pinned header for the voices list (does not scroll)
            HStack {
                // Left-aligned header over the name column
                Text("Voices")
                    .font(.title3)
                    .fontWeight(.semibold)
                    .frame(maxWidth: .infinity, alignment: .leading)

                // Trailing actions in a single hamburger menu
                Menu {
                    Button {
                        presentAddVoice()
                    } label: {
                        Label("Add Voice…", systemImage: "plus.circle")
                    }
                    Button {
                        synchronizeRates()
                    } label: {
                        Label("Synchronize Now", systemImage: "metronome.fill")
                    }
                    Divider()
                    Button {
                        withAnimation {
                            editMode?.wrappedValue = (editMode?.wrappedValue == .active) ? .inactive : .active
                        }
                    } label: {
                        Label((editMode?.wrappedValue == .active) ? "Done Reordering" : "Reorder",
                              systemImage: "arrow.up.arrow.down")
                    }
                } label: {
                    Image(systemName: "line.3.horizontal.circle")
                        .font(.title3)
                }
                .buttonStyle(.plain)
            }
            .padding(.horizontal)
            .padding(.bottom, 0)
            // List area (enables swipe actions)
            List {
                selectedVoicesSection()
            }
            .listStyle(.plain)
            .padding(.top, -6)
        }
        .sheet(isPresented: $showTuner) {
            // Wrap in a padded container so margins are guaranteed even if VoiceTunerView is edge-to-edge.
            VStack {
                VoiceTunerView(
                    tts: tunerEngine,
                    selectedID: $tunerSelection,
                    onChoose: {
                        applyTunerSelection()
                        showTuner = false
                    },
                    onCancel: {
                        showTuner = false
                    }
                )
            }
            .padding(.horizontal, 16)
            .frame(minWidth: 420, minHeight: 520)
            .presentationDetents([.large])
            .presentationDragIndicator(.visible)
        }
        .onAppear {
            // Keep baseline in sync on first load.
            if baseProfiles.isEmpty, !selectedProfiles.isEmpty {
                baseProfiles = selectedProfiles
            }
            // Pre-seed two voices so the chorus is playable immediately.
            // Seed only once on first appear.
            if selectedProfiles.isEmpty {
                seedInitialVoices(count: 2)
                applyGlobalAdjustments()
            }
        }
        // Safety net: when rows are added/removed, realign baseline and re-apply.
        .onChange(of: selectedProfiles.count) { _, _ in
            baseProfiles = selectedProfiles
            applyGlobalAdjustments()
        }
    }

    // New: Selected voices section with edit/remove
    @ViewBuilder
    private func selectedVoicesSection() -> some View {
        if selectedProfiles.isEmpty {
            Text("Tap “Add voice…” to choose voices and tune pitch/volume.")
                .foregroundStyle(.secondary)
                .padding(.vertical, 8)
        } else {
            ForEach(selectedProfiles, id: \.id) { profile in
                HStack(alignment: .firstTextBaseline, spacing: 8) {
                    // Name (left)
                    Text(resolvedName(for: profile.id))
                        .font(.subheadline)
                        .lineLimit(1)
                        .minimumScaleFactor(0.9)        // allow slight shrink on tight fits
                        .allowsTightening(true)
                        .truncationMode(.tail)
                        .layoutPriority(1)
                        .frame(maxWidth: .infinity, alignment: .leading)

                    Spacer(minLength: 0)
                    // Details (middle)
                    Text(String(format: "Speed %.2f · Pitch %.2f · Vol %.2f",
                                profile.rate, profile.pitch, profile.volume))
                        .font(.caption2)
                        .foregroundStyle(.secondary)
                        .lineLimit(1)
                        .minimumScaleFactor(0.9)        // allow slight shrink before truncation
                        .allowsTightening(true)
                        .truncationMode(.tail)
                        .frame(width: 190, alignment: .trailing)

                    // Timing (right, fixed width for column alignment)
                    if let d = lastDurationByID[profile.id] {
                        Text(String(format: "%.2fs", d))
                            .font(.footnote)
                            .monospacedDigit()
                            .foregroundStyle(.primary)
                            .frame(width: 40, alignment: .trailing)
                            .padding(.vertical, 2)
                            .background {
                                if calibratingVoiceID == profile.id {
                                    RoundedRectangle(cornerRadius: 4)
                                        .fill(Color.yellow.opacity(0.30))
                                }
                            }
                            .animation(.easeInOut(duration: 0.2), value: calibratingVoiceID)
                    } else {
                        Text("—")
                            .font(.footnote)
                            .foregroundStyle(.secondary)
                            .frame(width: 40, alignment: .trailing)
                            .padding(.vertical, 2)
                            .background {
                                if calibratingVoiceID == profile.id {
                                    RoundedRectangle(cornerRadius: 4)
                                        .fill(Color.yellow.opacity(0.30))
                                }
                            }
                            .animation(.easeInOut(duration: 0.2), value: calibratingVoiceID)
                    }
                    Image(systemName: "chevron.right")
                        .font(.caption2)
                        .foregroundStyle(.tertiary)
                        .frame(width: 6, alignment: .trailing)
                }
                .contentShape(Rectangle())
                .onTapGesture {
                    if let idx = selectedProfiles.firstIndex(where: { $0.id == profile.id }) {
                        presentEditVoice(index: idx)
                    }
                }
                .swipeActions(edge: .trailing, allowsFullSwipe: true) {
                    Button(role: .destructive) {
                        // Remove from the effective list and sync baseline so
                        // future global adjustments don’t resurrect this row.
                        let removedID = profile.id
                        if let idx = selectedProfiles.firstIndex(where: { $0.id == removedID }) {
                            selectedProfiles.remove(at: idx)
                        }
                        lastDurationByID.removeValue(forKey: removedID)
                        baseProfiles = selectedProfiles
                        applyGlobalAdjustments()
                    } label: {
                        Label("Remove", systemImage: "trash")
                    }
                }
            }
            // Attach reordering to the ForEach so it works on all platforms.
            .onMove { indices, newOffset in
                selectedProfiles.move(fromOffsets: indices, toOffset: newOffset)
                baseProfiles = selectedProfiles
                applyGlobalAdjustments()
            }
        }
    }

    // MARK: - Calibration (synchronize rates)
    private func synchronizeRates() {
        guard !selectedProfiles.isEmpty else { return }
        isCalibrating = true
        let phrase = customText
        // Cancel any in-flight calibration task
        calibrationTask?.cancel()
        calibrationTask = Task { @MainActor in
            // Use a dedicated engine for measurement to avoid interfering with the chorus engine
            let io = RealVoiceIO()
            defer {
                isCalibrating = false
                calibrationTask = nil
                // After calibration, refresh selectedProfiles from baseline with current global sliders
                // First, ensure baseline reflects any calibrated rate changes:
                baseProfiles = selectedProfiles
                // Apply global scaling/offset to produce effective profiles:
                var updated: [TTSVoiceProfile] = []
                updated.reserveCapacity(baseProfiles.count)
                for var p in baseProfiles {
                    // Amplified relative mapping (all Double to match TTSVoiceProfile.rate):
                    // - If rateScale > 1, move toward 1.0 by a fraction of headroom.
                    // - If rateScale < 1, move toward 0.0 by a fraction of current value.
                    let base: Double = p.rate
                    let newRate: Double = {
                        if rateScale >= 1.0 {
                            let t = max(0.0, min(1.0, rateScale - 1.0)) // 1.0→2.0 maps to 0…1
                            return (base + (1.0 - base) * t).clamped(to: 0.0...1.0)
                        } else {
                            let t = max(0.0, min(1.0, (1.0 - rateScale) / 0.75)) // 1.0→0.25 maps to 0…1
                            return (base - base * t).clamped(to: 0.0...1.0)
                        }
                    }()
                    p.rate = newRate
                    p.pitch = (p.pitch + Float(pitchOffset)).clamped(to: 0.5...2.0)
                    updated.append(p)
                }
                selectedProfiles = updated
            }

            for i in selectedProfiles.indices {
                if Task.isCancelled { return }
                // Ensure the IO has the current profile before measuring
                let voiceID = selectedProfiles[i].id
                calibratingVoiceID = voiceID
                await Task.yield()
                io.setVoiceProfile(selectedProfiles[i])

                // Calibrate this voice to the target duration
                let result = await VoiceTempoCalibrator.fitRate(
                    io: io,
                    voiceID: voiceID,
                    phrase: phrase,
                    targetSeconds: targetSeconds,
                    tolerance: 0.05,
                    maxIterations: 3
                )
                // Update the stored and baseline profile with the new rate and last measured duration
                selectedProfiles[i].rate = result.finalRate
                lastDurationByID[voiceID] = result.measured
                // Reflect progress live in the header “actual time” display
                lastChorusSeconds = result.measured
                // Give the UI a chance to refresh during calibration
                await Task.yield()
            }
            calibratingVoiceID = nil
        }
    }

    // MARK: - Header row components
    @ViewBuilder
    private func targetTimeRow() -> some View {
        HStack(spacing: 8) {
            Text("Target Time")
                .font(.footnote)
                .lineLimit(1)
                .layoutPriority(1)
            Text(String(format: "%.2fs", targetSeconds))
                .monospacedDigit()
                .foregroundStyle(.secondary)
            Stepper(value: $targetSeconds, in: 1.0...20.0, step: 0.25) {
                EmptyView()
            }
            .labelsHidden()
            .controlSize(.mini)
            Spacer()
            HStack(spacing: 6) {
                if isPlaying {
                    ProgressView().controlSize(.mini)
                }
                Text(lastChorusSeconds.map { String(format: "%.2fs", $0) } ?? "—s")
                    .monospacedDigit()
                    .foregroundStyle(.secondary)
                    .lineLimit(1)
            }
            .frame(minWidth: 60, alignment: .trailing)
        }
        .padding(.horizontal)
        .padding(.bottom, 4)
    }

    @ViewBuilder
    private func actionButtonsRow() -> some View {
        VStack(spacing: 6) {
            // Secondary action row: Synchronize or Stop (when calibrating/playing)
            HStack(spacing: 12) {
                Button {
                    if isCalibrating || isPlaying {
                        stopAll()
                    } else {
                        synchronizeRates()
                    }
                } label: {
                    Label(isCalibrating || isPlaying ? "Stop" : "Synchronize",
                          systemImage: isCalibrating || isPlaying ? "stop.fill" : "metronome.fill")
                }
                .buttonStyle(.bordered)
                .tint(isCalibrating || isPlaying ? .red : .secondary)
                .controlSize(.small)
                .disabled(selectedProfiles.isEmpty && !(isCalibrating || isPlaying))

                Spacer()

                if isCalibrating {
                    HStack(spacing: 6) {
                        ProgressView().controlSize(.small)
                        Text("Calibrating…").foregroundStyle(.secondary)
                    }
                }
            }

            // Primary action: Play or Stop
            Button {
                if isPlaying {
                    stopAll()
                } else {
                    startChorus()
                }
            } label: {
                Label(isPlaying ? "Stop" : "Play Chorus",
                      systemImage: isPlaying ? "stop.fill" : "play.fill")
            }
            .buttonStyle(.borderedProminent)
            .tint(isPlaying ? .red : .blue)
            .controlSize(.regular)
            .disabled(selectedProfiles.isEmpty && !isPlaying)
        }
        .padding(.bottom, 4)
    }

    @ViewBuilder
    private func globalAdjustmentsSection() -> some View {
        VStack(spacing: 8) {
            TunerSliderRow(
                title: "Speed",
                systemImage: "speedometer",
                value: $rateScale,
                range: 0.05...2.0,
                step: 0.01,
                formatted: { v in String(format: "%.2f×", Double(v)) }
            )
            .onChange(of: rateScale) { _, _ in applyGlobalAdjustments() }
            if rateScale < 0.1 {
                HStack { Spacer().frame(width: 50); Text("very slow").font(.caption2).foregroundStyle(.tertiary); Spacer() }
            }
            TunerSliderRow(title: "Pitch", systemImage: "waveform.path.ecg", value: $pitchOffset, range: -0.9...0.9, step: 0.01, formatted: { off in
                let absPitch = 1.0 + Double(off)
                return String(format: "%.2f", absPitch)
            }).onChange(of: pitchOffset) { _, _ in applyGlobalAdjustments() }
        }
    }

    private func startChorus() {
        Task {
            isPlaying = true
            let t0 = Date()
            await chorus.sing(customText, withVoiceProfiles: selectedProfiles)
            let elapsed = Date().timeIntervalSince(t0)
            // Update actual duration shown next to the target stepper
            self.lastChorusSeconds = elapsed
            isPlaying = false
        }
    }

    // Cancel any in-flight calibration and stop the chorus immediately.
    private func stopAll() {
        // Cancel calibration if running
        calibrationTask?.cancel()
        calibrationTask = nil
        isCalibrating = false
        // Stop any ongoing chorus playback
        chorus.stop()
        // Reflect stop in UI immediately; the sing task will return shortly.
        if isPlaying {
            isPlaying = false
        }
    }

    // Use system voices (RealVoiceIO no longer exposes availableVoices()).
    @MainActor func availableVoices() -> [TTSVoiceInfo] {
        SystemVoicesCache.all()
            .sorted { $0.name.localizedCaseInsensitiveCompare($1.name) == .orderedAscending }
    }

    /// Seed initial voices so users can play the chorus immediately.
    /// Picks `count` random distinct system voices from the current language and nudges pitch to differentiate.
    private func seedInitialVoices(count: Int = 2) {
        // Filter to current language base code (e.g., "en").
        let baseLang: String = {
            let tag = Locale.preferredLanguages.first ?? Locale.current.identifier
            if let dash = tag.firstIndex(of: "-") { return String(tag[..<dash]).lowercased() }
            return tag.lowercased()
        }()
        let list = availableVoices().filter {
            let lang = $0.language
            let code: String = {
                if let dash = lang.firstIndex(of: "-") { return String(lang[..<dash]).lowercased() }
                return lang.lowercased()
            }()
            return code == baseLang
        }
        guard !list.isEmpty else { return }

        // Random without replacement
        let slice = Array(list.shuffled().prefix(max(0, count)))
        var picks: [TTSVoiceProfile] = []
        let pitchOffsets: [Float] = [-0.05, 0.05, 0.1, -0.1]

        for (i, v) in slice.enumerated() {
            var p = TTSVoiceProfile(id: v.id, rate: 0.55, pitch: 1.0, volume: 1.0)
            if i < pitchOffsets.count {
                p.pitch = (p.pitch + pitchOffsets[i]).clamped(to: 0.5...2.0)
            }
            picks.append(p)
        }
        // Establish baseline and effective selections
        baseProfiles = picks
        selectedProfiles = picks
    }

    // MARK: - Tuner integration
    private func presentAddVoice() {
        editingIndex = nil
        tunerEngine = RealVoiceIO()
        // Prefer a random voice from the user’s preferred language; fall back to any.
        let baseLang: String = {
            let tag = Locale.preferredLanguages.first ?? Locale.current.identifier
            if let dash = tag.firstIndex(of: "-") { return String(tag[..<dash]).lowercased() }
            return tag.lowercased()
        }()
        let sameLang = availableVoices().filter {
            let lang = $0.language
            let code: String = {
                if let dash = lang.firstIndex(of: "-") { return String(lang[..<dash]).lowercased() }
                return lang.lowercased()
            }()
            return code == baseLang
        }
        let pool = sameLang.isEmpty ? availableVoices() : sameLang
        if let pick = pool.randomElement() {
            tunerSelection = pick.id
            let seed = TTSVoiceProfile(id: pick.id, rate: 0.55, pitch: 1.0, volume: 1.0)
            tunerEngine.setVoiceProfile(seed)
            tunerEngine.setDefaultVoiceProfile(seed)
        } else {
            tunerSelection = nil
        }
        showTuner = true
    }

    private func presentEditVoice(index: Int) {
        guard selectedProfiles.indices.contains(index) else { return }
        editingIndex = index
        tunerEngine = RealVoiceIO()
        // Seed tuner with current profile
        let prof = selectedProfiles[index]
        tunerEngine.setVoiceProfile(prof)
        tunerEngine.setDefaultVoiceProfile(prof) // ensure sliders reflect the current row exactly
        tunerSelection = prof.id
        showTuner = true
    }

    private func applyTunerSelection() {
        guard let id = tunerSelection else { return }
        // Prefer the specific profile returned by the tuner engine; fall back to its default;
        // finally, seed a mid profile if neither is available yet.
        var tuned: TTSVoiceProfile? = tunerEngine.getVoiceProfile(id: id)
        if tuned == nil, let def = tunerEngine.getDefaultVoiceProfile() {
            tuned = TTSVoiceProfile(id: id, rate: def.rate, pitch: def.pitch, volume: def.volume)
        }
        if tuned == nil {
            tuned = TTSVoiceProfile(id: id, rate: 0.55, pitch: 1.0, volume: 1.0)
        }
        guard let tuned else { return }
        if let idx = editingIndex, selectedProfiles.indices.contains(idx) {
            // Editing an existing row updates only that row
            selectedProfiles[idx] = tuned
        } else {
            // Always allow duplicates when adding
            selectedProfiles.append(tuned)
        }
        // Clear edit state
        editingIndex = nil
        tunerSelection = nil
        // Keep baseline aligned to effective list, then re-apply globals
        baseProfiles = selectedProfiles
        // Re-apply global adjustments so effective profiles reflect sliders
        applyGlobalAdjustments()
    }

    private func resolvedName(for id: String) -> String {
        if let v = availableVoices().first(where: { $0.id == id }) {
            return v.name
        }
        return "Voice"
    }

    // Apply global sliders to baseline -> effective profiles
    private func applyGlobalAdjustments() {
        guard !baseProfiles.isEmpty else { return }
        selectedProfiles = baseProfiles.map { base in
            var profile = base
            // Amplified relative mapping (Double)
            let baseRate: Double = profile.rate
            let newRate: Double = {
                if rateScale >= 1.0 {
                    // 1.0→2.0 maps to t: 0…1, push toward 1.0 by headroom
                    let t = max(0.0, min(1.0, rateScale - 1.0))
                    return (baseRate + (1.0 - baseRate) * t).clamped(to: 0.0...1.0)
                } else {
                    // 1.0→0.25 maps to t: 0…1, pull toward 0.0 by fraction of current
                    let t = max(0.0, min(1.0, (1.0 - rateScale) / 0.75))
                    return (baseRate - baseRate * t).clamped(to: 0.0...1.0)
                }
            }()
            profile.rate = newRate
            profile.pitch = (profile.pitch + Float(pitchOffset)).clamped(to: 0.5...2.0)
            return profile
        }
    }
}

struct VoiceChorusPlayground_Previews: PreviewProvider {
    static var previews: some View {
        Group {
            #if os(macOS)
            VoiceChorusPlayground()
                .frame(width: 520, height: 820) // taller, narrower for Mac preview
                .previewDisplayName("macOS")
            #else
            VoiceChorusPlayground()
                .previewDisplayName("iOS")
            #endif
        }
    }
}


// Clamp helper for global adjustments
private extension Comparable {
    func clamped(to range: ClosedRange<Self>) -> Self {
        min(max(self, range.lowerBound), range.upperBound)
    }
}
