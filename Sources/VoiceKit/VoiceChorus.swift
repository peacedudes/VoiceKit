//
//  VoiceChorus.swift
//  VoiceKit
//
//  Generated by GPT-5.1 (OpenAI) - collaborator: rdoggett
//  date: 11-19-2025
//
//  Sing with multiple voices in parallel using predefined profiles or system voice IDs.
//  - Accepts system voice ID or TTSVoiceProfile.
//  - Supports concurrent instances of the same voice with different settings.
//  - stop() to cancel.
//
import Foundation

@MainActor
public final class VoiceChorus {

    /// Engine type used by the chorus:
    /// a full voice box (VoiceIO) plus TTS tuning/preview (TTSConfigurable).
    private let makeEngine: () -> VoiceEngine
    private var engines: [VoiceEngine] = []
    private var tasks: [Task<Void, Never>] = []
    private var isRunning = false

    public init(makeEngine: @escaping () -> VoiceEngine) {
        self.makeEngine = makeEngine
    }

    /// Default initializer: creates a chorus that uses a new RealVoiceIO per channel.
    /// Hides the existential cast for casual use.
    public convenience init() {
        self.init(makeEngine: {
            RealVoiceIO() as VoiceEngine
        })
    }

    /// Ensure we have at least the needed number of engines ready.
    private func ensureEngines(count neededCount: Int) {
        while engines.count < neededCount {
            engines.append(makeEngine())
        }
    }

    /// Sing the same text with multiple voices in parallel.
    /// Enable custom settings for each engine.
    public func speak(_ text: String, withVoiceProfiles profiles: [TTSVoiceProfile]) async {
        guard !profiles.isEmpty else { return }
        stop() // reset any previous run
        isRunning = true

        ensureEngines(count: profiles.count)
        tasks = []

        for (index, profile) in profiles.enumerated() {
            let engine = engines[index]
            engine.setVoiceProfile(profile)
            let task = Task { @MainActor in
                if Task.isCancelled { return }
                await engine.speak(text, using: profile.id)
            }
            tasks.append(task)
        }

        for task in tasks { _ = await task.result }
        isRunning = false
        tasks.removeAll()
    }

    /// Stop all voices and cancel any in-flight chorus.
    public func stop() {
        guard isRunning || !tasks.isEmpty else { return }
        tasks.forEach { $0.cancel() }
        engines.forEach { $0.stopAll() }
        tasks.removeAll()
        isRunning = false
    }
}
