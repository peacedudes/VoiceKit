//
//  VoiceQueue.swift
//  VoiceKit
//
//  Generated by GPT-5 (OpenAI) — collaborator: rdoggett
//  date: 09-16-2025
//
//  A tiny orchestration layer for kid‑friendly sequencing of voice + SFX.
//  - Linear queues per channel; channels run in parallel.
//  - Smart SFX near-zero gap: pre-schedules the next clip before speak().
//  - Embedded SFX parsing: "Hello [sfx:ding] world" with resolver(name)->URL.
//  - Cancel-all stops everything immediately.
//
//  Notes:
//  - Uses any VoiceIO; when available, it calls TTSConfigurable.speak(_:using:)
//    to select specific voices. Otherwise it falls back to VoiceIO.speak(_).
//  - For near-zero SFX after speech, we pre-call prepareClip() when the next
//    item is .sfx; after speak returns, we await startPreparedClip().
//  - Parallel playback requires separate channels; by default, channel 0 uses
//    the provided VoiceIO; additional channels can be provided via factory.
//

import Foundation

@MainActor
public final class VoiceQueue {

    public enum Item: Sendable, Equatable {
        case speak(text: String, voiceID: String? = nil)
        case sfx(url: URL, gainDB: Float = 0)
        case pause(seconds: TimeInterval)

        public static func speak(_ text: String, voiceID: String? = nil) -> Item { .speak(text: text, voiceID: voiceID) }
        public static func sfx(_ url: URL, gainDB: Float = 0) -> Item { .sfx(url: url, gainDB: gainDB) }
        public static func pause(_ seconds: TimeInterval) -> Item { .pause(seconds: seconds) }
    }

    public typealias ChannelID = Int
    public typealias SFXResolver = (_ name: String) -> URL?

    private struct Channel {
        var io: VoiceIO
        var items: [Item] = []
        var task: Task<Void, Never>?
    }

    private var channels: [ChannelID: Channel] = [:]
    private let makeChannel: (() -> VoiceIO)?
    private var running = false
    private var cancelled = false

    public init(primary: VoiceIO, makeChannel: (() -> VoiceIO)? = nil) {
        self.channels[0] = Channel(io: primary, items: [], task: nil)
        self.makeChannel = makeChannel
    }

    // MARK: - Enqueue

    public func enqueue(_ item: Item, on channel: ChannelID = 0) {
        ensureChannel(channel)
        channels[channel]?.items.append(item)
    }

    @discardableResult
    public func enqueueSpeak(_ text: String, voiceID: String? = nil, on channel: ChannelID = 0) -> Self {
        enqueue(.speak(text: text, voiceID: voiceID), on: channel); return self
    }

    @discardableResult
    public func enqueueSFX(_ url: URL, gainDB: Float = 0, on channel: ChannelID = 0) -> Self {
        enqueue(.sfx(url: url, gainDB: gainDB), on: channel); return self
    }

    @discardableResult
    public func enqueuePause(_ seconds: TimeInterval, on channel: ChannelID = 0) -> Self {
        enqueue(.pause(seconds: seconds), on: channel); return self
    }

    // Parse "[sfx:name]" tokens and enqueue segments accordingly.
    // Example: "Hello [sfx:ding] world"
    @discardableResult
    public func enqueueParsingSFX(text: String, resolver: SFXResolver, defaultVoiceID: String? = nil, on channel: ChannelID = 0) -> Self {
        let parts = Self.parseTextForSFX(text)
        for part in parts {
            switch part {
            case .text(let text) where !text.isEmpty:
                enqueue(.speak(text: text, voiceID: defaultVoiceID), on: channel)
            case .sfx(let name):
                if let url = resolver(name) {
                    enqueue(.sfx(url: url, gainDB: 0), on: channel)
                }
            case .text: // empty text part; ignore
                break
            }
        }
        return self
    }

    public var isRunning: Bool { running }

    // MARK: - Control

    public func play() async {
        guard !running else { return }
        running = true
        cancelled = false

        // Launch a task per channel without mutating the dictionary while iterating it.
        let ids = Array(channels.keys)
        for id in ids {
            guard var channel = channels[id] else { continue }
            channel.task = Task { [weak self] in
                await self?.runChannel(id)
            }
            channels[id] = channel
        }

        // Await all channel tasks to finish
        for id in ids {
            _ = await channels[id]?.task?.value
        }

        running = false
    }

    public func cancelAll() {
        cancelled = true
        for (_, channel) in channels {
            channel.io.stopAll()
            channel.task?.cancel()
        }
    }

    // MARK: - Internals

    private func ensureChannel(_ id: ChannelID) {
        guard channels[id] == nil else { return }
        if let factory = makeChannel {
            channels[id] = Channel(io: factory(), items: [], task: nil)
        } else {
            // Without a factory we share channel 0 (serial behavior).
            if let primary = channels[0] {
                channels[id] = Channel(io: primary.io, items: [], task: nil)
            }
        }
    }

    private func runChannel(_ id: ChannelID) async {
        guard var channel = channels[id] else { return }
        var itemIndex = 0

        while itemIndex < channel.items.count, !cancelled, !Task.isCancelled {
            let item = channel.items[itemIndex]
            let nextItem = itemIndex + 1 < channel.items.count ? channel.items[itemIndex + 1] : nil

            switch item {
            case .speak(let text, let voiceID):
                // Pre-schedule SFX if next is a clip for near-zero gap.
                if case .sfx(let url, let gain)? = nextItem {
                    try? await channel.io.prepareClip(url: url, gainDB: gain)
                }

                if let tts = channel.io as? TTSConfigurable {
                    await tts.speak(text, using: voiceID)
                } else {
                    await channel.io.speak(text)
                }

                if case .sfx = nextItem {
                    // Await clip completion; RealVoiceIO auto-starts; others may need start call.
                    try? await channel.io.startPreparedClip()
                    itemIndex += 1 // consume the next .sfx
                }

            case .sfx(let url, let gain):
                try? await channel.io.playClip(url: url, gainDB: gain)

            case .pause(let seconds):
                try? await Task.sleep(nanoseconds: UInt64(max(0, seconds) * 1_000_000_000))
            }

            itemIndex += 1
        }

        // Clear consumed items on completion/cancel
        channel.items.removeAll()
        channels[id] = channel
    }

    // MARK: - Parsing

    internal enum Part {
        case text(String)
        case sfx(String)
    }

    internal static func parseTextForSFX(_ text: String) -> [Part] {
        // Pattern: [sfx: NAME] — NAME is any non-] text, leading whitespace allowed
        let pattern = #"\[sfx:\s*([^\]]+)\]"#
        guard let regex = try? NSRegularExpression(pattern: pattern) else { return [.text(text)] }

        var parts: [Part] = []
        var cursor = text.startIndex

        for match in regex.matches(in: text, range: NSRange(text.startIndex..<text.endIndex, in: text)) {
            guard let range = Range(match.range, in: text) else { continue }
            let before = String(text[cursor..<range.lowerBound])
            if !before.isEmpty { parts.append(.text(before)) }

            if let nameRange = Range(match.range(at: 1), in: text) {
                parts.append(.sfx(String(text[nameRange])))
            }

            cursor = range.upperBound
        }

        let tail = String(text[cursor..<text.endIndex])
        if !tail.isEmpty { parts.append(.text(tail)) }
        if parts.isEmpty { parts = [.text(text)] }
        return parts
    }
}
